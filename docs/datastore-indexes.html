<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:46.281561677"><title>Datastore Indexes | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"contents","level":0,"title":"Contents","anchor":"#contents"},{"id":"index-definition-and-structure","level":0,"title":"Index definition and structure","anchor":"#index-definition-and-structure"},{"id":"index-configuration","level":0,"title":"Index configuration","anchor":"#index-configuration"},{"id":"indexes-and-properties","level":0,"title":"Indexes and properties","anchor":"#indexes-and-properties"},{"id":"index-limits","level":0,"title":"Index limits","anchor":"#index-limits"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Datastore Indexes | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/datastore-indexes.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Datastore Indexes | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/datastore-indexes.html#webpage",
    "url": "writerside-documentation/datastore-indexes.html",
    "name": "Datastore Indexes | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Datastore-Indexes" data-main-title="Datastore Indexes" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Google-Cloud-Datastore.md|Google Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Datastore-Indexes" id="Datastore-Indexes.md">Datastore Indexes</h1><p id="-3d7kct_3">Every Datastore <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/queries" id="-3d7kct_12" data-external="true" rel="noopener noreferrer" target="_blank">query</a> computes its results using one or more <span class="emphasis" id="-3d7kct_13">indexes,</span> which contain entity keys in a sequence specified by the index's properties and, optionally, the entity's ancestors. The indexes are updated incrementally to reflect any changes the application makes to its entities, so that the correct results of all queries are available with no further computation needed.</p><p id="-3d7kct_4"><span class="control" id="-3d7kct_14">Important:</span> For an in-depth discussion of indexes and querying, see the article <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/articles/indexselection" id="-3d7kct_15" data-external="true" rel="noopener noreferrer" target="_blank">Index Selection and Advanced Search</a>.</p><p id="-3d7kct_5">App Engine predefines a simple index on each property of an entity. An App Engine application can define further custom indexes in an <span class="emphasis" id="-3d7kct_16"><a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/config/indexconfig" id="-3d7kct_19" data-external="true" rel="noopener noreferrer" target="_blank">index configuration file</a></span> named <code class="code" id="-3d7kct_17">datastore-indexes.xml</code>, which is generated in your application's <code class="code" id="-3d7kct_18">/war/WEB-INF/appengine-generated</code> directory. The development server automatically adds suggestions to this file as it encounters queries that cannot be executed with the existing indexes. You can tune indexes manually by editing the file before uploading the application.</p><p id="-3d7kct_6"><span class="control" id="-3d7kct_20">Note:</span> The index-based query mechanism supports a wide range of queries and is suitable for most applications. However, it does not support some kinds of query common in other database technologies: in particular, joins and aggregate queries aren't supported within the Datastore query engine. See the <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Restrictions_on_queries" id="-3d7kct_21" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page for limitations on Datastore queries.</p><section class="chapter"><h2 id="contents" data-toc="contents">Contents</h2><ol class="list _decimal" id="-3d7kct_22" type="1"><li class="list__item" id="-3d7kct_23"><p id="-3d7kct_27"><span id="-3d7kct_28">Index definition and structure</span></p></li><li class="list__item" id="-3d7kct_24"><p id="-3d7kct_29"><span id="-3d7kct_30">Index configuration</span></p></li><li class="list__item" id="-3d7kct_25"><p id="-3d7kct_31"><span id="-3d7kct_33">Indexes and properties</span></p><ol class="list _decimal" id="-3d7kct_32" type="1"><li class="list__item" id="-3d7kct_34"><p id="-3d7kct_36"><span id="-3d7kct_37">Properties with mixed value types</span></p></li><li class="list__item" id="-3d7kct_35"><p id="-3d7kct_38"><span id="-3d7kct_39">Unindexed properties</span></p></li></ol></li><li class="list__item" id="-3d7kct_26"><p id="-3d7kct_40"><span id="-3d7kct_41">Index limits</span></p></li></ol></section><section class="chapter"><h2 id="index-definition-and-structure" data-toc="index-definition-and-structure">Index definition and structure</h2><p id="-3d7kct_42">An index is defined on a list of properties of a given <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="-3d7kct_61" data-external="true" rel="noopener noreferrer" target="_blank">entity kind</a>, with a corresponding order (ascending or descending) for each property. For use with ancestor queries, the index may also optionally include an entity's ancestors.</p><p id="-3d7kct_43">An index table contains a column for every property named in the index's definition. Each row of the table represents an entity in the Datastore that is a potential result for queries based on the index. An entity is included in the index only if it has an indexed value set for every property used in the index; if the index definition refers to a property for which the entity has no value, that entity will not appear in the index and hence will never be returned as a result for any query based on the index.</p><p id="-3d7kct_44"><span class="control" id="-3d7kct_62">Note:</span> The Datastore distinguishes between an entity that does not possess a property and one that possesses the property with a null value (<code class="code" id="-3d7kct_63">null</code>). If you explicitly assign a null value to an entity's property, that entity may be included in the results of a query referring to that property.</p><p id="-3d7kct_45"><span class="control" id="-3d7kct_64">Note:</span> Indexes composed of multiple properties require that each individual property must not be set to <span id="-3d7kct_65">unindexed</span>.</p><p id="-3d7kct_46">The rows of an index table are sorted first by ancestor and then by property values, in the order specified in the index definition. The <span class="emphasis" id="-3d7kct_66">perfect index</span> for a query, which allows the query to be executed most efficiently, is defined on the following properties, in order:</p><ol class="list _decimal" id="-3d7kct_47" type="1"><li class="list__item" id="-3d7kct_67"><p id="-3d7kct_70">Properties used in equality filters</p></li><li class="list__item" id="-3d7kct_68"><p id="-3d7kct_71">Property used in an inequality filter (of which there can be <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Inequality_filters_are_limited_to_at_most_one_property" id="-3d7kct_72" data-external="true" rel="noopener noreferrer" target="_blank">no more than one</a>)</p></li><li class="list__item" id="-3d7kct_69"><p id="-3d7kct_73">Properties used in sort orders</p></li></ol><p id="-3d7kct_48">This ensures that all results for every possible execution of the query appear in consecutive rows of the table. The Datastore executes a query using a perfect index by the following steps:</p><ol class="list _decimal" id="-3d7kct_49" type="1"><li class="list__item" id="-3d7kct_74"><p id="-3d7kct_77">Identifies the index corresponding to the query's kind, filter properties, filter operators, and sort orders.</p></li><li class="list__item" id="-3d7kct_75"><p id="-3d7kct_78">Scans from the beginning of the index to the first entity that meets all of the query's filter conditions.</p></li><li class="list__item" id="-3d7kct_76"><p id="-3d7kct_79">Continues scanning the index, returning each entity in turn, until it</p><ul class="list _bullet" id="-3d7kct_80"><li class="list__item" id="-3d7kct_81"><p id="-3d7kct_84">encounters an entity that does not meet the filter conditions, or</p></li><li class="list__item" id="-3d7kct_82"><p id="-3d7kct_85">reaches the end of the index, or</p></li><li class="list__item" id="-3d7kct_83"><p id="-3d7kct_86">has collected the maximum number of results requested by the query.</p></li></ul></li></ol><p id="-3d7kct_50">For example, consider the following query:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addFilter(&quot;lastName&quot;, Query.FilterOperator.EQUAL, &quot;Smith&quot;)
                .addFilter(&quot;height&quot;, Query.FilterOperator.LESS_THAN, 72)
                .addSort(&quot;height&quot;, Query.SortDirection.DESCENDING);
</div><p id="-3d7kct_52">The perfect index for this query is a table of keys for entities of kind <code class="code" id="-3d7kct_87">Person</code>, with columns for the values of the <code class="code" id="-3d7kct_88">lastName</code> and <code class="code" id="-3d7kct_89">height</code> properties. The index is sorted first in ascending order by <code class="code" id="-3d7kct_90">lastName</code> and then in descending order by <code class="code" id="-3d7kct_91">height</code>.</p><p id="-3d7kct_53">Two queries of the same form but with different filter values use the same index. For example, the following query uses the same index as the one above:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addFilter(&quot;lastName&quot;, Query.FilterOperator.EQUAL, &quot;Jones&quot;)
                .addFilter(&quot;height&quot;, Query.FilterOperator.LESS_THAN, 63)
                .addSort(&quot;height&quot;, Query.SortDirection.DESCENDING);
</div><p id="-3d7kct_55">The following two queries also use the same index, despite their different forms:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addFilter(&quot;lastName&quot;, Query.FilterOperator.EQUAL, &quot;Friedkin&quot;)
                .addFilter(&quot;firstName&quot;, Query.FilterOperator.EQUAL, &quot;Damian&quot;)
                .addSort(&quot;height&quot;, Query.SortDirection.ASCENDING);
</div><p id="-3d7kct_57">and</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addFilter(&quot;lastName&quot;, Query.FilterOperator.EQUAL, &quot;Blair&quot;)
                .addSort(&quot;firstName&quot;, Query.SortDirection.ASCENDING)
                .addSort(&quot;height&quot;, Query.SortDirection.ASCENDING);
</div><p id="-3d7kct_59"><span class="control" id="-3d7kct_92">Note:</span> You can get a list of your application's indexes at runtime by calling the methods <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreService#getIndexes()" id="-3d7kct_93" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_95">DatastoreService.getIndexes()</code></a> or <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService#getIndexes()" id="-3d7kct_94" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_96">AsyncDatastoreService.getIndexes()</code></a>.</p><p id="-3d7kct_60"><span class="control" id="-3d7kct_97">Caution:</span> Using a perfect index can significantly increase the cost of writing entities, especially in the case of <span id="-3d7kct_98">exploding indexes</span>. The article <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/articles/indexselection" id="-3d7kct_99" data-external="true" rel="noopener noreferrer" target="_blank">Index Selection and Advanced Search</a> describes how you can manually select indexes to avoid these problems.</p></section><section class="chapter"><h2 id="index-configuration" data-toc="index-configuration">Index configuration</h2><p id="-3d7kct_100">By default, the Datastore automatically predefines an index for each property of each entity kind. These predefined indexes are sufficient to perform many simple queries, such as equality-only queries and simple inequality queries. For all other queries, the application must define the indexes it needs in an <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/config/indexconfig" id="-3d7kct_107" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-3d7kct_110">index configuration file</span></a> named <code class="code" id="-3d7kct_108">datastore-indexes.xml</code>. If the application tries to perform a query that cannot be executed with the available indexes (either predefined or specified in the index configuration file), the query will fail with a <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreNeedIndexException" id="-3d7kct_109" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_111">DatastoreNeedIndexException</code></a>.</p><p id="-3d7kct_101">The Datastore builds automatic indexes for queries of the following forms:</p><ul class="list _bullet" id="-3d7kct_102"><li class="list__item" id="-3d7kct_112"><p id="-3d7kct_117">Kindless queries using only ancestor and key filters</p></li><li class="list__item" id="-3d7kct_113"><p id="-3d7kct_118">Queries using only ancestor and equality filters</p></li><li class="list__item" id="-3d7kct_114"><p id="-3d7kct_119">Queries using only inequality filters (which are <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Inequality_filters_are_limited_to_at_most_one_property" id="-3d7kct_120" data-external="true" rel="noopener noreferrer" target="_blank">limited to a single property</a>)</p></li><li class="list__item" id="-3d7kct_115"><p id="-3d7kct_121">Queries using only ancestor filters, equality filters on properties, and inequality filters on keys</p></li><li class="list__item" id="-3d7kct_116"><p id="-3d7kct_122">Queries with no filters and only one sort order on a property, either ascending or descending</p></li></ul><p id="-3d7kct_103">Other forms of query require their indexes to be specified in the index configuration file, including:</p><ul class="list _bullet" id="-3d7kct_104"><li class="list__item" id="-3d7kct_123"><p id="-3d7kct_127">Queries with ancestor and inequality filters</p></li><li class="list__item" id="-3d7kct_124"><p id="-3d7kct_128">Queries with one or more inequality filters on a property and one or more equality filters on other properties</p></li><li class="list__item" id="-3d7kct_125"><p id="-3d7kct_129">Queries with a sort order on keys in descending order</p></li><li class="list__item" id="-3d7kct_126"><p id="-3d7kct_130">Queries with multiple sort orders</p></li></ul><p id="-3d7kct_105"><span class="control" id="-3d7kct_131">Note:</span> The App Engine SDK automatically suggests indexes that are appropriate for most applications. Depending on your application's use of the Datastore and the size and shape of your data, manual adjustments to your indexes may be warranted. For example, writing entities with multiple property values may result in an <span id="-3d7kct_132">exploding index</span> with high write costs.</p><p id="-3d7kct_106"><span class="control" id="-3d7kct_133">Note:</span> The development web server can help make it easier to manage your index configuration file. Instead of failing to execute a query that requires an index and does not have one, the development web server can generate an index configuration that would allow the query to succeed. If your local testing of an application exercises every possible query the application will issue, using every combination of filter and sort order, the generated entries will represent a complete set of indexes. If your testing does not exercise every possible query form, you can review and adjust the index configuration file before uploading the application.</p></section><section class="chapter"><h2 id="indexes-and-properties" data-toc="indexes-and-properties">Indexes and properties</h2><p id="-3d7kct_134">Here are a few special considerations to keep in mind about indexes and how they relate to the properties of entities in the Datastore:</p><section class="chapter"><h3 id="properties-with-mixed-value-types" data-toc="properties-with-mixed-value-types">Properties with mixed value types</h3><p id="-3d7kct_137">When two entities have properties of the same name but different value types, an index of the property sorts the entities first by <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Value_type_sort_order" id="-3d7kct_139" data-external="true" rel="noopener noreferrer" target="_blank">value type</a> and then by a <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Value_type_sort_order" id="-3d7kct_140" data-external="true" rel="noopener noreferrer" target="_blank">secondary ordering</a> appropriate to each type. For example, if two entities each have a property named <code class="code" id="-3d7kct_141">age</code>, one with an integer value and one with a string value, the entity with the integer value always precedes the one with the string value when sorted by the <code class="code" id="-3d7kct_142">age</code> property, regardless of the property values themselves.</p><p id="-3d7kct_138">This is especially worth noting in the case of integers and floating-point numbers, which are treated as separate types by the Datastore. Because all integers are sorted before all floats, a property with the integer value <code class="code" id="-3d7kct_143">38</code> is sorted before one with the floating-point value <code class="code" id="-3d7kct_144">37.5</code>.</p></section><section class="chapter"><h3 id="unindexed-properties" data-toc="unindexed-properties">Unindexed properties</h3><p id="-3d7kct_145">If you know you will never have to filter or sort on a particular property, you can tell the Datastore not to maintain index entries for that property by declaring the property <span class="emphasis" id="-3d7kct_155">unindexed</span>. This lowers the cost of running your application by decreasing the number of Datastore writes it has to perform. An entity with an unindexed property behaves as if the property were not set: queries with a filter or sort order on the unindexed property will never match that entity.</p><p id="-3d7kct_146"><span class="control" id="-3d7kct_156">Note:</span> If a property appears in an index composed of multiple properties, then setting it to unindexed will prevent it from being indexed in the composed index.</p><p id="-3d7kct_147">For example, suppose that an entity has properties <span class="control" id="-3d7kct_157">a</span> and <span class="control" id="-3d7kct_158">b</span> and that you want to create an index able to satisfy queries like <code class="code" id="-3d7kct_159">WHERE a =&quot;bike&quot; and b=&quot;red&quot;</code>. Also suppose that you don't care about the queries <code class="code" id="-3d7kct_160">WHERE a=&quot;bike&quot;</code> and <code class="code" id="-3d7kct_161">WHERE b=&quot;red&quot;</code>. If you set <span class="control" id="-3d7kct_162">a</span> to unindexed and create an index for <span class="control" id="-3d7kct_163">a</span> and <span class="control" id="-3d7kct_164">b</span> Datastore will not create index entries for the <span class="control" id="-3d7kct_165">a</span> and <span class="control" id="-3d7kct_166">b</span> index and so the <code class="code" id="-3d7kct_167">WHERE a=&quot;bike&quot; and b=&quot;red&quot;</code> query won't work. For Datastore to create entries for the <span class="control" id="-3d7kct_168">a</span> and <span class="control" id="-3d7kct_169">b</span> indexes, both <span class="control" id="-3d7kct_170">a</span> and <span class="control" id="-3d7kct_171">b</span> must be indexed.</p><p id="-3d7kct_148"><span class="control" id="-3d7kct_172">Note:</span> In addition to any unindexed properties you declare explicitly, those typed as long text strings (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Text" id="-3d7kct_173" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_176">Text</code></a>), long byte strings (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Blob" id="-3d7kct_174" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_177">Blob</code></a>), and embedded entities (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/EmbeddedEntity" id="-3d7kct_175" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_178">EmbeddedEntity</code></a>) are automatically treated as unindexed.</p><p id="-3d7kct_149">In the low-level Java Datastore API, properties are defined as indexed or unindexed on a per-entity basis, depending on the method you use to set them (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PropertyContainer#setProperty(java.lang.String,%20java.lang.Object)" id="-3d7kct_179" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_181">setProperty()</code></a> or <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PropertyContainer#setUnindexedProperty(java.lang.String,%20java.lang.Object)" id="-3d7kct_180" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_182">setUnindexedProperty()</code></a>):</p><div class="code-block" data-lang="none">
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

Key acmeKey = KeyFactory.createKey(&quot;Company&quot;, &quot;Acme&quot;);

Entity tom = new Entity(&quot;Person&quot;, &quot;Tom&quot;, acmeKey);
tom.setProperty(&quot;name&quot;, &quot;Tom&quot;);
tom.setProperty(&quot;age&quot;, 32);
datastore.put(tom);

Entity lucy = new Entity(&quot;Person&quot;, &quot;Lucy&quot;, acmeKey);
lucy.setProperty(&quot;name&quot;, &quot;Lucy&quot;);
lucy.setUnindexedProperty(&quot;age&quot;, 29);
datastore.put(lucy);

Filter ageFilter = new FilterPredicate(&quot;age&quot;, FilterOperator.GREATER_THAN, 25);

Query q = new Query(&quot;Person&quot;)
                .setAncestor(acmeKey)
                .setFilter(ageFilter);

// Returns tom but not lucy, because her age is unindexed
List&lt;Entity&gt; results = datastore.prepare(q)
                                .asList(FetchOptions.Builder.withDefaults());
</div><p id="-3d7kct_151">You can change an indexed property to unindexed by resetting its value with <code class="code" id="-3d7kct_183">setUnindexedProperty()</code>, or from unindexed to indexed by resetting it with <code class="code" id="-3d7kct_184">setProperty()</code>.</p><p id="-3d7kct_152">Note, however, that changing a property from unindexed to indexed does not affect any existing entities that may have been created before the change. Queries filtering on the property will not return such existing entities, because the entities weren't written to the query's index when they were created. To make the entities accessible by future queries, you must rewrite them to the Datastore so that they will be entered in the appropriate indexes. That is, you must do the following for each such existing entity:</p><ol class="list _decimal" id="-3d7kct_153" type="1"><li class="list__item" id="-3d7kct_185"><p id="-3d7kct_187">Retrieve (get) the entity from the Datastore.</p></li><li class="list__item" id="-3d7kct_186"><p id="-3d7kct_188">Write (put) the entity back to the Datastore.</p></li></ol><p id="-3d7kct_154">Similarly, changing a property from indexed to unindexed only affects entities subsequently written to the Datastore. The index entries for any existing entities with that property will continue to exist until the entities are updated or deleted. To avoid unwanted results, you must purge your code of all queries that filter or sort by the (now unindexed) property.</p></section></section><section class="chapter"><h2 id="index-limits" data-toc="index-limits">Index limits</h2><p id="-3d7kct_189">The Datastore imposes <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/datastore/#Java_Quotas_and_limits" id="-3d7kct_213" data-external="true" rel="noopener noreferrer" target="_blank">limits</a> on the number and overall size of index entries that can be associated with a single entity. These limits are large, and most applications are not affected. However, there are circumstances in which you might encounter the limits.</p><p id="-3d7kct_190">As described <span id="-3d7kct_214">above</span>, the Datastore creates an entry in a predefined index for every property of every entity except long text strings (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Text" id="-3d7kct_215" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_221">Text</code></a>), long byte strings (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Blob" id="-3d7kct_216" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_222">Blob</code></a>), and embedded entities (<a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/EmbeddedEntity" id="-3d7kct_217" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_223">EmbeddedEntity</code></a>) and those you have explicitly declared as <span id="-3d7kct_218">unindexed</span>. The property may also be included in additional, custom indexes declared in your <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/docs/java/config/indexconfig" id="-3d7kct_219" data-external="true" rel="noopener noreferrer" target="_blank">index configuration file</a> (<code class="code" id="-3d7kct_220">datastore-indexes.xml</code>). Provided that an entity has no list properties, it will have at most one entry in each such custom index (for non-ancestor indexes) or one for each of the entity's ancestors (for ancestor indexes). Each of these index entries must be updated every time the value of the property changes.</p><p id="-3d7kct_191">For a property that has a single value for each entity, each possible value needs to be stored just once per entity in the property's predefined index. Even so, it is possible for an entity with a large number of such single-valued properties to exceed the index entry or size limit. Similarly, an entity that can have multiple values for the same property requires a separate index entry for each value; again, if the number of possible values is large, such an entity can exceed the entry limit.</p><p id="-3d7kct_192">The situation becomes worse in the case of entities with multiple properties, each of which can take on multiple values. To accommodate such an entity, the index must include an entry for every possible <span class="emphasis" id="-3d7kct_224">combination</span> of property values. Custom indexes that refer to multiple properties, each with multiple values, can &quot;explode&quot; combinatorially, requiring large numbers of entries for an entity with only a relatively small number of possible property values. Such <span class="emphasis" id="-3d7kct_225">exploding indexes</span> can dramatically increase the cost of writing an entity to the Datastore, because of the large number of index entries that must be updated, and also can easily cause the entity to exceed the index entry or size limit.</p><p id="-3d7kct_193">Consider the query</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Widget&quot;)
                .addFilter(&quot;x&quot;, Query.FilterOperator.EQUAL, 1)
                .addFilter(&quot;y&quot;, Query.FilterOperator.EQUAL, 2)
                .addSort(&quot;date&quot;, Query.SortDirection.ASCENDING);
</div><p id="-3d7kct_195">which causes the SDK to suggest the following index:</p><div class="code-block" data-lang="none">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;datastore-indexes&gt;
  &lt;datastore-index kind=&quot;Widget&quot;&gt;
    &lt;property name=&quot;x&quot; direction=&quot;asc&quot; /&gt;
    &lt;property name=&quot;y&quot; direction=&quot;asc&quot; /&gt;
    &lt;property name=&quot;date&quot; direction=&quot;asc&quot; /&gt;
  &lt;/datastore-index&gt;
&lt;/datastore-indexes&gt;
</div><p id="-3d7kct_197">This index will require a total of <code class="code" id="-3d7kct_226">|x|</code> <code class="code" id="-3d7kct_227">*</code> <code class="code" id="-3d7kct_228">|y|</code> <code class="code" id="-3d7kct_229">*</code> <code class="code" id="-3d7kct_230">|date|</code> entries for each entity (where <code class="code" id="-3d7kct_231">|x|</code> denotes the number of values associated with the entity for property <code class="code" id="-3d7kct_232">x</code>). For example, the following code</p><div class="code-block" data-lang="none">
Entity widget = new Entity(&quot;Widget&quot;);
widget.setProperty(&quot;x&quot;, Arrays.asList(1, 2, 3, 4));
widget.setProperty(&quot;y&quot;, Arrays.asList(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;));
widget.setProperty(&quot;date&quot;, new Date());
ds.put(widget);
</div><p id="-3d7kct_199">creates an entity with four values for property <code class="code" id="-3d7kct_233">x</code>, three values for property <code class="code" id="-3d7kct_234">y</code>, and <code class="code" id="-3d7kct_235">date</code> set to the current date. This will require 12 index entries, one for each possible combination of property values:</p><p id="-3d7kct_200">(<code class="code" id="-3d7kct_236">1</code>, <code class="code" id="-3d7kct_237">&quot;red&quot;</code>, <code class="code" id="-3d7kct_238">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_239">1</code>, <code class="code" id="-3d7kct_240">&quot;green&quot;</code>, <code class="code" id="-3d7kct_241">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_242">1</code>, <code class="code" id="-3d7kct_243">&quot;blue&quot;</code>, <code class="code" id="-3d7kct_244">&lt;now&gt;</code>)</p><p id="-3d7kct_201">(<code class="code" id="-3d7kct_245">2</code>, <code class="code" id="-3d7kct_246">&quot;red&quot;</code>, <code class="code" id="-3d7kct_247">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_248">2</code>, <code class="code" id="-3d7kct_249">&quot;green&quot;</code>, <code class="code" id="-3d7kct_250">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_251">2</code>, <code class="code" id="-3d7kct_252">&quot;blue&quot;</code>, <code class="code" id="-3d7kct_253">&lt;now&gt;</code>)</p><p id="-3d7kct_202">(<code class="code" id="-3d7kct_254">3</code>, <code class="code" id="-3d7kct_255">&quot;red&quot;</code>, <code class="code" id="-3d7kct_256">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_257">3</code>, <code class="code" id="-3d7kct_258">&quot;green&quot;</code>, <code class="code" id="-3d7kct_259">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_260">3</code>, <code class="code" id="-3d7kct_261">&quot;blue&quot;</code>, <code class="code" id="-3d7kct_262">&lt;now&gt;</code>)</p><p id="-3d7kct_203">(<code class="code" id="-3d7kct_263">4</code>, <code class="code" id="-3d7kct_264">&quot;red&quot;</code>, <code class="code" id="-3d7kct_265">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_266">4</code>, <code class="code" id="-3d7kct_267">&quot;green&quot;</code>, <code class="code" id="-3d7kct_268">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_269">4</code>, <code class="code" id="-3d7kct_270">&quot;blue&quot;</code>, <code class="code" id="-3d7kct_271">&lt;now&gt;</code>)</p><p id="-3d7kct_204">When the same property is repeated multiple times, the Datastore can detect exploding indexes and suggest an alternative index. However, in all other circumstances (such as the query defined in this example), the Datastore will generate an exploding index. In this case, you can circumvent the exploding index by manually configuring an index in your index configuration file:</p><div class="code-block" data-lang="none">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;datastore-indexes&gt;
  &lt;datastore-index kind=&quot;Widget&quot;&gt;
    &lt;property name=&quot;x&quot; direction=&quot;asc&quot; /&gt;
    &lt;property name=&quot;date&quot; direction=&quot;asc&quot; /&gt;
  &lt;/datastore-index&gt;
  &lt;datastore-index kind=&quot;Widget&quot;&gt;
    &lt;property name=&quot;y&quot; direction=&quot;asc&quot; /&gt;
    &lt;property name=&quot;date&quot; direction=&quot;asc&quot; /&gt;
  &lt;/datastore-index&gt;
&lt;/datastore-indexes&gt;
</div><p id="-3d7kct_206">This reduces the number of entries needed to only <code class="code" id="-3d7kct_272">(|x|</code> <code class="code" id="-3d7kct_273">*</code> <code class="code" id="-3d7kct_274">|date|</code> <code class="code" id="-3d7kct_275">+</code> <code class="code" id="-3d7kct_276">|y|</code> <code class="code" id="-3d7kct_277">*</code> <code class="code" id="-3d7kct_278">|date|)</code>, or 7 entries instead of 12:</p><p id="-3d7kct_207">(<code class="code" id="-3d7kct_279">1</code>, <code class="code" id="-3d7kct_280">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_281">2</code>, <code class="code" id="-3d7kct_282">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_283">3</code>, <code class="code" id="-3d7kct_284">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_285">4</code>, <code class="code" id="-3d7kct_286">&lt;now&gt;</code>)</p><p id="-3d7kct_208">(<code class="code" id="-3d7kct_287">&quot;red&quot;</code>, <code class="code" id="-3d7kct_288">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_289">&quot;green&quot;</code>, <code class="code" id="-3d7kct_290">&lt;now&gt;</code>) (<code class="code" id="-3d7kct_291">&quot;blue&quot;</code>, <code class="code" id="-3d7kct_292">&lt;now&gt;</code>)</p><p id="-3d7kct_209">Any put operation that would cause an index to exceed the index entry or size limit will fail with an <a href="https://web.archive.org/web/20160424230615/http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html" id="-3d7kct_293" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-3d7kct_298">IllegalArgumentException</code></a>. The text of the exception describes which limit was exceeded (<code class="code" id="-3d7kct_294">&quot;Too many indexed properties&quot;</code> or <code class="code" id="-3d7kct_295">&quot;Index entries too large&quot;</code>) and which custom index was the cause. If you create a new index that would exceed the limits for any entity when built, queries against the index will fail and the index will appear in the <code class="code" id="-3d7kct_296">Error</code> state in the App Engine Administration Console. To handle such <code class="code" id="-3d7kct_297">Error</code> indexes,</p><ol class="list _decimal" id="-3d7kct_210" type="1"><li class="list__item" id="-3d7kct_299"><p id="-3d7kct_304">Remove the index from your index configuration file (<code class="code" id="-3d7kct_305">datastore-indexes.xml</code>).</p></li><li class="list__item" id="-3d7kct_300"><p id="-3d7kct_306">Run the application configuration command <code class="code" id="-3d7kct_307">AppCfg</code> <code class="code" id="-3d7kct_308">vacuum_indexes</code>.</p></li><li class="list__item" id="-3d7kct_301"><p id="-3d7kct_309">Either</p><ul class="list _bullet" id="-3d7kct_310"><li class="list__item" id="-3d7kct_311"><p id="-3d7kct_313">reformulate the index definition and corresponding queries, or</p></li><li class="list__item" id="-3d7kct_312"><p id="-3d7kct_314">remove the entities that are causing the index to explode.</p></li></ul></li><li class="list__item" id="-3d7kct_302"><p id="-3d7kct_315">Add the index back to <code class="code" id="-3d7kct_316">datastore-indexes.xml</code>.</p></li><li class="list__item" id="-3d7kct_303"><p id="-3d7kct_317">Run <code class="code" id="-3d7kct_318">AppCfg</code> <code class="code" id="-3d7kct_319">update_indexes</code>.</p></li></ol><p id="-3d7kct_211">You can avoid exploding indexes by avoiding queries that would require a custom index using a list property. As described above, this includes queries with multiple sort orders or queries with a mix of equality and inequality filters.</p><p id="-3d7kct_212"><span class="control" id="-3d7kct_320">Important:</span> For more information on avoiding exploding indexes, see the article <a href="https://web.archive.org/web/20160424230615/https://cloud.google.com/appengine/articles/indexselection" id="-3d7kct_321" data-external="true" rel="noopener noreferrer" target="_blank">Index Selection and Advanced Search</a>.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="projection-queries.html" class="navigation-links__prev">Projection Queries</a><a href="transactions.html" class="navigation-links__next">Transactions</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>