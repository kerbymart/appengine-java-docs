<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:46.080553538"><title>Datastore Queries | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"contents","level":0,"title":"Contents","anchor":"#contents"},{"id":"java-query-interface","level":0,"title":"Java query interface","anchor":"#java-query-interface"},{"id":"query-structure","level":0,"title":"Query structure","anchor":"#query-structure"},{"id":"restrictions-on-queries","level":0,"title":"Restrictions on queries","anchor":"#restrictions-on-queries"},{"id":"retrieving-results","level":0,"title":"Retrieving results","anchor":"#retrieving-results"},{"id":"offsets-versus-cursors","level":0,"title":"Offsets versus cursors","anchor":"#offsets-versus-cursors"},{"id":"query-cursors","level":0,"title":"Query cursors","anchor":"#query-cursors"},{"id":"data-consistency","level":0,"title":"Data consistency","anchor":"#data-consistency"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Datastore Queries | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/datastore-queries.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Datastore Queries | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/datastore-queries.html#webpage",
    "url": "writerside-documentation/datastore-queries.html",
    "name": "Datastore Queries | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Datastore-Queries" data-main-title="Datastore Queries" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Google-Cloud-Datastore.md|Google Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Datastore-Queries" id="Datastore-Queries.md">Datastore Queries</h1><p id="-q2vm5v_3">A Datastore <span class="emphasis" id="-q2vm5v_18">query</span> retrieves <span class="emphasis" id="-q2vm5v_19"><a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities" id="-q2vm5v_26" data-external="true" rel="noopener noreferrer" target="_blank">entities</a></span> from the App Engine Datastore that meet a specified set of conditions. The query operates on entities of a given <span class="emphasis" id="-q2vm5v_20"><a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="-q2vm5v_27" data-external="true" rel="noopener noreferrer" target="_blank">kind</a></span>; it can specify <span class="emphasis" id="-q2vm5v_21"><span id="-q2vm5v_28">filters</span></span> on the entities' property values, keys, and ancestors, and can return zero or more entities as <span class="emphasis" id="-q2vm5v_22">results.</span> A query can also specify <span class="emphasis" id="-q2vm5v_23"><span id="-q2vm5v_29">sort orders</span></span> to sequence the results by their property values. The results include all entities that have at least one (possibly null) value for every property named in the filters and sort orders, and whose property values meet all the specified filter criteria. The query can return entire entities, <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/projectionqueries" id="-q2vm5v_24" data-external="true" rel="noopener noreferrer" target="_blank">projected entities</a>, or just entity <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/#Java_Kinds_keys_and_identifiers" id="-q2vm5v_25" data-external="true" rel="noopener noreferrer" target="_blank">keys</a>.</p><p id="-q2vm5v_4">A typical query includes the following:</p><ul class="list _bullet" id="-q2vm5v_5"><li class="list__item" id="-q2vm5v_30"><p id="-q2vm5v_33">An <span class="emphasis" id="-q2vm5v_34"><a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="-q2vm5v_35" data-external="true" rel="noopener noreferrer" target="_blank">entity kind</a></span> to which the query applies</p></li><li class="list__item" id="-q2vm5v_31"><p id="-q2vm5v_36">Zero or more <span class="emphasis" id="-q2vm5v_37"><span id="-q2vm5v_38">filters</span></span> based on the entities' property values, keys, and ancestors</p></li><li class="list__item" id="-q2vm5v_32"><p id="-q2vm5v_39">Zero or more <span class="emphasis" id="-q2vm5v_40"><span id="-q2vm5v_41">sort orders</span></span> to sequence the results</p></li></ul><p id="-q2vm5v_6">When executed, the query retrieves all entities of the given kind that satisfy all of the given filters, sorted in the specified order. Queries execute as read-only.</p><p id="-q2vm5v_7"><span class="control" id="-q2vm5v_42">Note:</span> To conserve memory and improve performance, a query should, whenever possible, specify a limit on the number of results returned.</p><p id="-q2vm5v_8">Every Datastore query computes its results using one or more <span class="emphasis" id="-q2vm5v_43"><a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/indexes" id="-q2vm5v_44" data-external="true" rel="noopener noreferrer" target="_blank">indexes</a>,</span> which contain entity keys in a sequence specified by the index's properties and, optionally, the entity's ancestors. The indexes are updated incrementally to reflect any changes the application makes to its entities, so that the correct results of all queries are available with no further computation needed.</p><p id="-q2vm5v_9"><span class="control" id="-q2vm5v_45">Note:</span> The index-based query mechanism supports a wide range of queries and is suitable for most applications. However, it does not support some kinds of query common in other database technologies: in particular, joins and aggregate queries aren't supported within the Datastore query engine. See <span id="-q2vm5v_46">Restrictions on Queries</span>, below, for limitations on Datastore queries.</p><section class="chapter"><h2 id="contents" data-toc="contents">Contents</h2><ol class="list _decimal" id="-q2vm5v_47" type="1"><li class="list__item" id="-q2vm5v_48"><p id="-q2vm5v_55"><span id="-q2vm5v_56">Java query interface</span></p></li><li class="list__item" id="-q2vm5v_49"><p id="-q2vm5v_57"><span id="-q2vm5v_59">Query structure</span></p><ol class="list _decimal" id="-q2vm5v_58" type="1"><li class="list__item" id="-q2vm5v_60"><p id="-q2vm5v_63"><span id="-q2vm5v_65">Filters</span></p><ol class="list _decimal" id="-q2vm5v_64" type="1"><li class="list__item" id="-q2vm5v_66"><p id="-q2vm5v_69"><span id="-q2vm5v_70">Property filters</span></p></li><li class="list__item" id="-q2vm5v_67"><p id="-q2vm5v_71"><span id="-q2vm5v_72">Key filters</span></p></li><li class="list__item" id="-q2vm5v_68"><p id="-q2vm5v_73"><span id="-q2vm5v_74">Ancestor filters</span></p></li></ol></li><li class="list__item" id="-q2vm5v_61"><p id="-q2vm5v_75"><span id="-q2vm5v_76">Sort orders</span></p></li><li class="list__item" id="-q2vm5v_62"><p id="-q2vm5v_77"><span id="-q2vm5v_79">Special query types</span></p><ol class="list _decimal" id="-q2vm5v_78" type="1"><li class="list__item" id="-q2vm5v_80"><p id="-q2vm5v_85"><span id="-q2vm5v_86">Kindless queries</span></p></li><li class="list__item" id="-q2vm5v_81"><p id="-q2vm5v_87"><span id="-q2vm5v_88">Ancestor queries</span></p></li><li class="list__item" id="-q2vm5v_82"><p id="-q2vm5v_89"><span id="-q2vm5v_90">Kindless ancestor queries</span></p></li><li class="list__item" id="-q2vm5v_83"><p id="-q2vm5v_91"><span id="-q2vm5v_92">Keys-only queries</span></p></li><li class="list__item" id="-q2vm5v_84"><p id="-q2vm5v_93"><span id="-q2vm5v_94">Projection queries</span></p></li></ol></li></ol></li><li class="list__item" id="-q2vm5v_50"><p id="-q2vm5v_95"><span id="-q2vm5v_96">Restrictions on queries</span></p></li><li class="list__item" id="-q2vm5v_51"><p id="-q2vm5v_97"><span id="-q2vm5v_98">Retrieving results</span></p></li><li class="list__item" id="-q2vm5v_52"><p id="-q2vm5v_99"><span id="-q2vm5v_100">Offsets versus cursors</span></p></li><li class="list__item" id="-q2vm5v_53"><p id="-q2vm5v_101"><span id="-q2vm5v_103">Query cursors</span></p><ol class="list _decimal" id="-q2vm5v_102" type="1"><li class="list__item" id="-q2vm5v_104"><p id="-q2vm5v_106"><span id="-q2vm5v_107">Limitations of cursors</span></p></li><li class="list__item" id="-q2vm5v_105"><p id="-q2vm5v_108"><span id="-q2vm5v_109">Cursors and data updates</span></p></li></ol></li><li class="list__item" id="-q2vm5v_54"><p id="-q2vm5v_110"><span id="-q2vm5v_111">Data consistency</span></p></li></ol></section><section class="chapter"><h2 id="java-query-interface" data-toc="java-query-interface">Java query interface</h2><p id="-q2vm5v_112">The low-level Java Datastore API provides class <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query.html" id="-q2vm5v_120" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_122">Query</code></a> for constructing queries and the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery.html" id="-q2vm5v_121" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_123">PreparedQuery</code></a> interface for retrieving entities from the Datastore:</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.Query.Filter;
import com.google.appengine.api.datastore.Query.FilterPredicate;
import com.google.appengine.api.datastore.Query.FilterOperator;
import com.google.appengine.api.datastore.Query.CompositeFilter;
import com.google.appengine.api.datastore.Query.CompositeFilterOperator;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Entity;

// Get the Datastore Service
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

Filter heightMinFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minHeight);

Filter heightMaxFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.LESS_THAN_OR_EQUAL,
                      maxHeight);

//Use CompositeFilter to combine multiple filters
Filter heightRangeFilter =
  CompositeFilterOperator.and(heightMinFilter, heightMaxFilter);


// Use class Query to assemble a query
Query q = new Query(&quot;Person&quot;).setFilter(heightRangeFilter);

// Use PreparedQuery interface to retrieve results
PreparedQuery pq = datastore.prepare(q);


for (Entity result : pq.asIterable()) {
  String firstName = (String) result.getProperty(&quot;firstName&quot;);
  String lastName = (String) result.getProperty(&quot;lastName&quot;);
  Long height = (Long) result.getProperty(&quot;height&quot;);

  System.out.println(firstName + &quot; &quot; + lastName + &quot;, &quot; + height + &quot; inches tall&quot;);
}
</div><p id="-q2vm5v_114">Notice the use of <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query.FilterPredicate.html" id="-q2vm5v_124" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_127">FilterPredicate</code></a> and <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query.CompositeFilter.html" id="-q2vm5v_125" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_128">CompositeFilter</code></a> to construct filters. If you're setting only one filter on a query, you can just use <code class="code" id="-q2vm5v_126">FilterPredicate</code> by itself:</p><div class="code-block" data-lang="none">
Filter heightMinFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minHeight);

Query q = new Query(&quot;Person&quot;).setFilter(heightMinFilter);
</div><p id="-q2vm5v_116">However, if you want to set more than one filter on a query, you must use <code class="code" id="-q2vm5v_129">CompositeFilter</code>, which requires at least two filters. The example above uses the shortcut helper <code class="code" id="-q2vm5v_130">CompositeFilterOperator.and</code>; the following example shows one way of constructing a composite OR filter:</p><div class="code-block" data-lang="none">
Filter tooShortFilter =
  new FilterPredicate(&quot;height&quot;, FilterOperator.LESS_THAN, minHeight);

Filter tooTallFilter =
  new FilterPredicate(&quot;height&quot;, FilterOperator.GREATER_THAN, maxHeight);

Filter heightOutOfRangeFilter =
  CompositeFilterOperator.or(tooShortFilter, tooTallFilter);

Query q = new Query(&quot;Person&quot;).setFilter(heightOutOfRangeFilter);
</div><p id="-q2vm5v_118"><span class="control" id="-q2vm5v_131">Caution:</span> Note that using an OR filter will cause multiple queries to be executed against the underlying Datastore.</p><p id="-q2vm5v_119"><span class="control" id="-q2vm5v_132">Note:</span> The properties being filtered on must have a corresponding predefined index which can be defined in your <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/config/indexconfig" id="-q2vm5v_133" data-external="true" rel="noopener noreferrer" target="_blank">index configuration file</a> (<code class="code" id="-q2vm5v_134">datastore-indexes.xml</code>).</p></section><section class="chapter"><h2 id="query-structure" data-toc="query-structure">Query structure</h2><p id="-q2vm5v_135">A query can specify an <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="-q2vm5v_139" data-external="true" rel="noopener noreferrer" target="_blank">entity kind</a>, zero or more <span id="-q2vm5v_140">filters</span>, and zero or more <span id="-q2vm5v_141">sort orders</span>.</p><section class="chapter"><h3 id="filters" data-toc="filters">Filters</h3><p id="-q2vm5v_142">A query's <span class="emphasis" id="-q2vm5v_146">filters</span> set constraints on the <span id="-q2vm5v_147">properties</span>, <span id="-q2vm5v_148">keys</span>, and <span id="-q2vm5v_149">ancestors</span> of the entities to be retrieved.</p><section class="chapter"><h4 id="property-filters" data-toc="property-filters">Property filters</h4><p id="-q2vm5v_150">A <span class="emphasis" id="-q2vm5v_161">property filter</span> specifies</p><ul class="list _bullet" id="-q2vm5v_151"><li class="list__item" id="-q2vm5v_162"><p id="-q2vm5v_165">A property name</p></li><li class="list__item" id="-q2vm5v_163"><p id="-q2vm5v_166">A comparison operator</p></li><li class="list__item" id="-q2vm5v_164"><p id="-q2vm5v_167">A property value</p></li></ul><p id="-q2vm5v_152">For example:</p><div class="code-block" data-lang="none">
Filter propertyFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minHeight);
Query q = new Query(&quot;Person&quot;).setFilter(propertyFilter);
</div><p id="-q2vm5v_154">The property value must be supplied by the application; it cannot refer to or be calculated in terms of other properties. An entity satisfies the filter if it has a property of the given name whose value compares to the value specified in the filter in the manner described by the comparison operator.</p><p id="-q2vm5v_155">The comparison operator can be any of the following (defined as enumerated constants in the nested class <code class="code" id="-q2vm5v_168"></code><a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query.FilterOperator" id="-q2vm5v_169" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_170">Query.FilterOperator</code></a>):</p><div class="table-wrapper"><table class="wide" id="-q2vm5v_156"><thead><tr class="ijRowHead" id="-q2vm5v_171"><th id="-q2vm5v_179"><p>Operator</p></th><th id="-q2vm5v_180"><p>Meaning</p></th></tr></thead><tbody><tr id="-q2vm5v_172"><td id="-q2vm5v_181"><p><code class="code" id="-q2vm5v_183">EQUAL</code></p></td><td id="-q2vm5v_182"><p>Equal to</p></td></tr><tr id="-q2vm5v_173"><td id="-q2vm5v_184"><p><code class="code" id="-q2vm5v_186">LESS_THAN</code></p></td><td id="-q2vm5v_185"><p>Less than</p></td></tr><tr id="-q2vm5v_174"><td id="-q2vm5v_187"><p><code class="code" id="-q2vm5v_189">LESS_THAN_OR_EQUAL</code></p></td><td id="-q2vm5v_188"><p>Less than or equal to</p></td></tr><tr id="-q2vm5v_175"><td id="-q2vm5v_190"><p><code class="code" id="-q2vm5v_192">GREATER_THAN</code></p></td><td id="-q2vm5v_191"><p>Greater than</p></td></tr><tr id="-q2vm5v_176"><td id="-q2vm5v_193"><p><code class="code" id="-q2vm5v_195">GREATER_THAN_OR_EQUAL</code></p></td><td id="-q2vm5v_194"><p>Greater than or equal to</p></td></tr><tr id="-q2vm5v_177"><td id="-q2vm5v_196"><p><code class="code" id="-q2vm5v_198">NOT_EQUAL</code></p></td><td id="-q2vm5v_197"><p>Not equal to</p></td></tr><tr id="-q2vm5v_178"><td id="-q2vm5v_199"><p><code class="code" id="-q2vm5v_201">IN</code></p></td><td id="-q2vm5v_200"><p>Member of (equal to any of the values in a specified list)</p></td></tr></tbody></table></div><p id="-q2vm5v_157">The <code class="code" id="-q2vm5v_202">NOT_EQUAL</code> operator actually performs two queries: one in which all other filters are unchanged and the <code class="code" id="-q2vm5v_203">NOT_EQUAL</code> filter is replaced with a <code class="code" id="-q2vm5v_204">LESS_THAN</code> filter, and one where it is replaced with a <code class="code" id="-q2vm5v_205">GREATER_THAN</code> filter. The results are then merged, in order. A query can have no more than one <code class="code" id="-q2vm5v_206">NOT_EQUAL</code> filter, and a query that has one cannot have any other inequality filters.</p><p id="-q2vm5v_158">The <code class="code" id="-q2vm5v_207">IN</code> operator also performs multiple queries: one for each item in the specified list, with all other filters unchanged and the <code class="code" id="-q2vm5v_208">IN</code> filter replaced with an <code class="code" id="-q2vm5v_209">EQUAL</code> filter. The results are merged in order of the items in the list. If a query has more than one <code class="code" id="-q2vm5v_210">IN</code> filter, it is performed as multiple queries, one for each possible <span class="emphasis" id="-q2vm5v_211">combination</span> of values in the <code class="code" id="-q2vm5v_212">IN</code> lists.</p><p id="-q2vm5v_159">A single query containing <code class="code" id="-q2vm5v_213">NOT_EQUAL</code> or <code class="code" id="-q2vm5v_214">IN</code> operators is limited to no more than 30 subqueries.</p><p id="-q2vm5v_160">For more information about how <code class="code" id="-q2vm5v_215">NOT_EQUAL</code> and <code class="code" id="-q2vm5v_216">IN</code> queries translate to multiple queries in a JDO/JPA framework, see the article <a href="https://web.archive.org/web/20160424230618/http://gae-java-persistence.blogspot.com/2009/12/queries-with-and-in-filters.html" id="-q2vm5v_217" data-external="true" rel="noopener noreferrer" target="_blank">Queries with != and IN filters</a>.</p></section><section class="chapter"><h4 id="key-filters" data-toc="key-filters">Key filters</h4><p id="-q2vm5v_218">To filter on the value of an entity's key, use the special property <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Entity#KEY_RESERVED_PROPERTY" id="-q2vm5v_225" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_226">Entity.KEY_RESERVED_PROPERTY</code></a>:</p><div class="code-block" data-lang="none">
Filter keyFilter =
  new FilterPredicate(Entity.KEY_RESERVED_PROPERTY,
                      FilterOperator.GREATER_THAN,
                      lastSeenKey)
Query q =  new Query(&quot;Person&quot;).setFilter(keyFilter);
</div><p id="-q2vm5v_220">Ascending sorts on <code class="code" id="-q2vm5v_227">Entity.KEY_RESERVED_PROPERTY</code> are also supported.</p><p id="-q2vm5v_221">When comparing for inequality, keys are ordered by the following criteria, in order:</p><ol class="list _decimal" id="-q2vm5v_222" type="1"><li class="list__item" id="-q2vm5v_228"><p id="-q2vm5v_231">Ancestor path</p></li><li class="list__item" id="-q2vm5v_229"><p id="-q2vm5v_232">Entity kind</p></li><li class="list__item" id="-q2vm5v_230"><p id="-q2vm5v_233">Identifier (key name or numeric ID)</p></li></ol><p id="-q2vm5v_223">Elements of the ancestor path are compared similarly: by kind (string), then by key name or numeric ID. Kinds and key names are strings and are ordered by byte value; numeric IDs are integers and are ordered numerically. If entities with the same parent and kind use a mix of key name strings and numeric IDs, those with numeric IDs precede those with key names.</p><p id="-q2vm5v_224">Queries on keys use indexes just like queries on properties and require custom indexes in the same cases, with a couple of exceptions: inequality filters or an ascending sort order on the key do not require a custom index, but a descending sort order on the key does. As with all queries, the development web server creates appropriate entries in the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/indexes#Java_Index_configuration" id="-q2vm5v_234" data-external="true" rel="noopener noreferrer" target="_blank">index configuration file</a> when a query that needs a custom index is tested.</p></section><section class="chapter"><h4 id="ancestor-filters" data-toc="ancestor-filters">Ancestor filters</h4><p id="-q2vm5v_235">You can filter your Datastore queries to a specified <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Ancestor_paths" id="-q2vm5v_238" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-q2vm5v_239">ancestor</span></a>, so that the results returned will include only entities descended from that ancestor:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .setAncestor(ancestorKey);
</div><p id="-q2vm5v_237"><span class="control" id="-q2vm5v_240">Caution:</span> Passing <code class="code" id="-q2vm5v_241">null</code> as the ancestor key does <span class="emphasis" id="-q2vm5v_242">not</span> query for root entities (those without ancestors). This type of query is not currently supported and will return an error.</p></section></section><section class="chapter"><h3 id="sort-orders" data-toc="sort-orders">Sort orders</h3><p id="-q2vm5v_243">A query <span class="emphasis" id="-q2vm5v_251">sort order</span> specifies</p><ul class="list _bullet" id="-q2vm5v_244"><li class="list__item" id="-q2vm5v_252"><p id="-q2vm5v_254">A property name</p></li><li class="list__item" id="-q2vm5v_253"><p id="-q2vm5v_255">A sort direction (ascending or descending)</p></li></ul><p id="-q2vm5v_245">For example:</p><div class="code-block" data-lang="none">
// Order alphabetically by last name:
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING);

// Order by height, tallest to shortest:
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;height&quot;, SortDirection.DESCENDING);
</div><p id="-q2vm5v_247">If a query includes multiple sort orders, they are applied in the sequence specified. The following example sorts first by ascending last name and then by descending height:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING)
                .addSort(&quot;height&quot;, SortDirection.DESCENDING);
</div><p id="-q2vm5v_249">If no sort orders are specified, the results are returned in the order they are retrieved from the Datastore.</p><p id="-q2vm5v_250"><span class="control" id="-q2vm5v_256">Note:</span> Because of the way the App Engine Datastore executes queries, if a query specifies inequality filters on a property and sort orders on other properties, the property used in the inequality filters must be ordered before the other properties.</p></section><section class="chapter"><h3 id="special-query-types" data-toc="special-query-types">Special query types</h3><p id="-q2vm5v_257">Some specific types of query deserve special mention:</p><section class="chapter"><h4 id="kindless-queries" data-toc="kindless-queries">Kindless queries</h4><p id="-q2vm5v_263">A query with no kind and no ancestor filter retrieves all of the entities of an application from the Datastore. This includes entities created and managed by other App Engine features, such as <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/stats" id="-q2vm5v_265" data-external="true" rel="noopener noreferrer" target="_blank">statistics entities</a> and <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/blobstore/package-summary" id="-q2vm5v_266" data-external="true" rel="noopener noreferrer" target="_blank">Blobstore metadata entities</a> (if any). Such <span class="emphasis" id="-q2vm5v_267">kindless queries</span> cannot include filters or sort orders on property values. They can, however, filter on entity keys by specifying <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Entity#KEY_RESERVED_PROPERTY" id="-q2vm5v_268" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_269">Entity.KEY_RESERVED_PROPERTY</code></a> as the property name:</p><div class="code-block" data-lang="none">
Filter keyFilter =
  new FilterPredicate(Entity.KEY_RESERVED_PROPERTY,
                      FilterOperator.GREATER_THAN,
                      lastSeenKey)
Query q =  new Query().setFilter(keyFilter);
</div></section><section class="chapter"><h4 id="ancestor-queries" data-toc="ancestor-queries">Ancestor queries</h4><p id="-q2vm5v_270">A query with an <span id="-q2vm5v_273">ancestor filter</span> limits its results to the specified entity and its descendants:</p><div class="code-block" data-lang="none">
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

Entity tom = new Entity(&quot;Person&quot;, &quot;Tom&quot;);
Key tomKey = tom.getKey();
datastore.put(tom);


Entity weddingPhoto = new Entity(&quot;Photo&quot;, tomKey);
weddingPhoto.setProperty(&quot;imageURL&quot;,
                         &quot;http://domain.com/some/path/to/wedding_photo.jpg&quot;);

Entity babyPhoto = new Entity(&quot;Photo&quot;, tomKey);
babyPhoto.setProperty(&quot;imageURL&quot;,
                      &quot;http://domain.com/some/path/to/baby_photo.jpg&quot;);

Entity dancePhoto = new Entity(&quot;Photo&quot;, tomKey);
dancePhoto.setProperty(&quot;imageURL&quot;,
                       &quot;http://domain.com/some/path/to/dance_photo.jpg&quot;);

Entity campingPhoto = new Entity(&quot;Photo&quot;);
campingPhoto.setProperty(&quot;imageURL&quot;,
                         &quot;http://domain.com/some/path/to/camping_photo.jpg&quot;);

List&lt;Entity&gt; photoList = Arrays.asList(weddingPhoto, babyPhoto,
                                       dancePhoto, campingPhoto);
datastore.put(photoList);


Query photoQuery = new Query(&quot;Photo&quot;)
                         .setAncestor(tomKey);  


// This returns weddingPhoto, babyPhoto, and dancePhoto,
// but not campingPhoto, because tom is not an ancestor
List&lt;Entity&gt; results = datastore.prepare(photoQuery)
                                .asList(FetchOptions.Builder.withDefaults());
</div><p id="-q2vm5v_272"><span class="control" id="-q2vm5v_274">Note:</span> Setting an <span id="-q2vm5v_275">ancestor filter</span> allows for strongly consistent queries. Queries without an ancestor filter only return eventually consistent results.</p></section><section class="chapter"><h4 id="kindless-ancestor-queries" data-toc="kindless-ancestor-queries">Kindless ancestor queries</h4><p id="-q2vm5v_276">A kindless query that includes an ancestor filter will retrieve the specified ancestor and all of its descendants, regardless of kind. This type of query does not require custom indexes. Like all kindless queries, it cannot include filters or sort orders on property values, but can filter on the entity's key:</p><div class="code-block" data-lang="none">
Filter keyFilter =
  new FilterPredicate(Entity.KEY_RESERVED_PROPERTY,
                      FilterOperator.GREATER_THAN,
                      lastSeenKey)
Query q =  new Query()
  .setAncestor(ancestorKey)
  .setFilter(keyFilter);
</div><p id="-q2vm5v_278">The following example illustrates how to retrieve all entities descended from a given ancestor:</p><div class="code-block" data-lang="none">
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

Entity tom = new Entity(&quot;Person&quot;, &quot;Tom&quot;);
Key tomKey = tom.getKey();
datastore.put(tom);


Entity weddingPhoto = new Entity(&quot;Photo&quot;, tomKey);
weddingPhoto.setProperty(&quot;imageURL&quot;,
                         &quot;http://domain.com/some/path/to/wedding_photo.jpg&quot;);

Entity weddingVideo = new Entity(&quot;Video&quot;, tomKey);
weddingVideo.setProperty(&quot;videoURL&quot;,
                         &quot;http://domain.com/some/path/to/wedding_video.avi&quot;);

List&lt;Entity&gt; mediaList = Arrays.asList(weddingPhoto, weddingVideo);
datastore.put(mediaList);


// By default, ancestor queries include the specified ancestor itself.
// The following filter excludes the ancestor from the query results.
Filter keyFilter
  = new FilterPredicate(Entity.KEY_RESERVED_PROPERTY,
                        FilterOperator.GREATER_THAN,
                        tomKey)

Query mediaQuery = new Query()
  .setAncestor(tomKey)
  .setFilter(keyFilter);


// Returns both weddingPhoto and weddingVideo,
// even though they are of different entity kinds
List&lt;Entity&gt; results = datastore.prepare(mediaQuery)
  .asList(FetchOptions.Builder.withDefaults());
</div></section><section class="chapter"><h4 id="keys-only-queries" data-toc="keys-only-queries">Keys-only queries</h4><p id="-q2vm5v_280">A <span class="emphasis" id="-q2vm5v_283">keys-only query</span> returns just the keys of the result entities instead of the entities themselves, at lower latency and cost than retrieving entire entities:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .setKeysOnly();
</div><p id="-q2vm5v_282">It is often more economical to do a keys-only query first, and then fetch a subset of entities from the results, rather than executing a general query which may fetch more entities than you actually need.</p></section><section class="chapter"><h4 id="projection-queries" data-toc="projection-queries">Projection queries</h4><p id="-q2vm5v_284">Sometimes all you really need from the results of a query are the values of a few specific properties. In such cases, you can use a <span class="emphasis" id="-q2vm5v_285">projection query</span> to retrieve just the properties you're actually interested in, at lower latency and cost than retrieving the entire entity; see the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/projectionqueries" id="-q2vm5v_286" data-external="true" rel="noopener noreferrer" target="_blank">Projection Queries</a> page for details.</p></section></section></section><section class="chapter"><h2 id="restrictions-on-queries" data-toc="restrictions-on-queries">Restrictions on queries</h2><p id="-q2vm5v_287">The nature of the index query mechanism imposes certain restrictions on what a query can do:</p><section class="chapter"><h3 id="entities-lacking-a-property-named-in-the-query-are-ignored" data-toc="entities-lacking-a-property-named-in-the-query-are-ignored">Entities lacking a property named in the query are ignored</h3><p id="-q2vm5v_296">Entities of the same kind need not have the same properties. To be eligible as a query result, an entity must possess a value (possibly null) for every property named in the query's filters and sort orders. If not, the entity is omitted from the indexes used to execute the query and consequently will not be included in the query's results.</p><p id="-q2vm5v_297"><span class="control" id="-q2vm5v_298">Note:</span> It is not possible to query for entities that are specifically <span class="emphasis" id="-q2vm5v_299">lacking</span> a given property. One alternative is to use <code class="code" id="-q2vm5v_300">null</code> for the default property value, then filter for entities with <code class="code" id="-q2vm5v_301">null</code> as the value of that property.</p></section><section class="chapter"><h3 id="filtering-on-unindexed-properties-returns-no-results" data-toc="filtering-on-unindexed-properties-returns-no-results">Filtering on unindexed properties returns no results</h3><p id="-q2vm5v_302">A query can't find property values that aren't indexed, nor can it sort on such properties. See the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/indexes#Java_Unindexed_properties" id="-q2vm5v_303" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Indexes</a> page for a detailed discussion of unindexed properties.</p></section><section class="chapter"><h3 id="inequality-filters-are-limited-to-at-most-one-property" data-toc="inequality-filters-are-limited-to-at-most-one-property">Inequality filters are limited to at most one property</h3><p id="-q2vm5v_304">To avoid having to scan the entire index, the query mechanism relies on all of a query's potential results being adjacent to one another in the index. To satisfy this constraint, a single query may not use inequality comparisons (<code class="code" id="-q2vm5v_310">LESS_THAN</code>, <code class="code" id="-q2vm5v_311">LESS_THAN_OR_EQUAL</code>, <code class="code" id="-q2vm5v_312">GREATER_THAN</code>, <code class="code" id="-q2vm5v_313">GREATER_THAN_OR_EQUAL</code>, <code class="code" id="-q2vm5v_314">NOT_EQUAL</code>) on more than one property across all of its filters. For example, the following query is valid, because both inequality filters apply to the same property:</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.Query.Filter;
import com.google.appengine.api.datastore.Query.FilterPredicate;
import com.google.appengine.api.datastore.Query.FilterOperator;
import com.google.appengine.api.datastore.Query.CompositeFilter;
import com.google.appengine.api.datastore.Query.CompositeFilterOperator;

Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Filter birthYearMaxFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.LESS_THAN_OR_EQUAL,
                      maxBirthYear);
 
Filter birthYearRangeFilter =
  CompositeFilterOperator.and(birthYearMinFilter, birthYearMaxFilter);

Query q = new Query(&quot;Person&quot;).setFilter(birthYearRangeFilter);
</div><p id="-q2vm5v_306">However, this query is <span class="emphasis" id="-q2vm5v_315">not</span> valid, because it uses inequality filters on two different properties:</p><div class="code-block" data-lang="none">
Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Filter heightMaxFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.LESS_THAN_OR_EQUAL,
                      maxHeight);
  
Filter invalidFilter =
  CompositeFilterOperator.and(birthYearMinFilter, heightMaxFilter);

Query q = new Query(&quot;Person&quot;).setFilter(invalidFilter);
</div><p id="-q2vm5v_308">Note that a query <span class="emphasis" id="-q2vm5v_316">can</span> combine equality (<code class="code" id="-q2vm5v_317">EQUAL</code>) filters for different properties, along with one or more inequality filters on a single property. Thus the following <span class="emphasis" id="-q2vm5v_318">is</span> a valid query:</p><div class="code-block" data-lang="none">
Filter lastNameFilter =
  new FilterPredicate(&quot;lastName&quot;,
                      FilterOperator.EQUAL,
                      targetLastName);

Filter cityFilter =
  new FilterPredicate(&quot;city&quot;,
                      FilterOperator.EQUAL,
                      targetCity);

Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Filter birthYearMaxFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.LESS_THAN_OR_EQUAL,
                      maxBirthYear);

Filter validFilter = CompositeFilterOperator.and(lastNameFilter,
                                                 cityFilter,
                                                 birthYearMinFilter,
                                                 birthYearMaxFilter);

Query q = new Query(&quot;Person&quot;).setFilter(validFilter);
</div></section><section class="chapter"><h3 id="ordering-of-query-results-is-undefined-when-no-sort-order-is-specified" data-toc="ordering-of-query-results-is-undefined-when-no-sort-order-is-specified">Ordering of query results is undefined when no sort order is specified</h3><p id="-q2vm5v_319">When a query does not specify a sort order, the results are returned in the order they are retrieved. As the Datastore implementation evolves (or if an application's indexes change), this order may change. Therefore, if your application requires its query results in a particular order, be sure to specify that sort order explicitly in the query.</p></section><section class="chapter"><h3 id="sort-orders-are-ignored-on-properties-with-equality-filters" data-toc="sort-orders-are-ignored-on-properties-with-equality-filters">Sort orders are ignored on properties with equality filters</h3><p id="-q2vm5v_320">Queries that include an equality filter for a given property ignore any sort order specified for that property. This is a simple optimization to save needless processing for single-valued properties, since all results have the same value for the property and so no further sorting is needed. Multiple-valued properties, however, may have additional values besides the one matched by the equality filter. Because this use case is rare and applying the sort order would be expensive and require extra indexes, the Datastore query planner simply ignores the sort order even in the multiple-valued case. This may cause query results to be returned in a different order than the sort order appears to imply.</p></section><section class="chapter"><h3 id="properties-used-in-inequality-filters-must-be-sorted-first" data-toc="properties-used-in-inequality-filters-must-be-sorted-first">Properties used in inequality filters must be sorted first</h3><p id="-q2vm5v_321">To retrieve all results that match an inequality filter, a query scans the index for the first row matching the filter, then scans forward until it encounters a nonmatching row. For the consecutive rows to encompass the complete result set, they must be ordered by the property used in the inequality filter before any other properties. Thus if a query specifies one or more inequality filters along with one or more sort orders, the first sort order must refer to the same property named in the inequality filters. The following is a valid query:</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.Query.Filter;
import com.google.appengine.api.datastore.Query.FilterPredicate;
import com.google.appengine.api.datastore.Query.FilterOperator;
import com.google.appengine.api.datastore.Query.CompositeFilter;
import com.google.appengine.api.datastore.Query.CompositeFilterOperator;
import com.google.appengine.api.datastore.Query.SortDirection;

Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Query q = new Query(&quot;Person&quot;)
                .setFilter(birthYearMinFilter)
                .addSort(&quot;birthYear&quot;, SortDirection.ASCENDING)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING);
</div><p id="-q2vm5v_323">This query is <span class="emphasis" id="-q2vm5v_327">not</span> valid, because it doesn't sort on the property used in the inequality filter:</p><div class="code-block" data-lang="none">
Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Query q = new Query(&quot;Person&quot;)
                .setFilter(birthYearMinFilter)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING);
</div><p id="-q2vm5v_325">Similarly, this query is not valid because the property used in the inequality filter is not the first one sorted:</p><div class="code-block" data-lang="none">
Filter birthYearMinFilter =
  new FilterPredicate(&quot;birthYear&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minBirthYear);

Query q = new Query(&quot;Person&quot;)
                .setFilter(birthYearMinFilter)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING)
                .addSort(&quot;birthYear&quot;, SortDirection.ASCENDING);
</div></section><section class="chapter"><h3 id="properties-with-multiple-values-can-behave-in-surprising-ways" data-toc="properties-with-multiple-values-can-behave-in-surprising-ways">Properties with multiple values can behave in surprising ways</h3><p id="-q2vm5v_328">Because of the way they're indexed, entities with multiple values for the same property can sometimes interact with query filters and sort orders in unexpected and surprising ways.</p><p id="-q2vm5v_329">If a query has multiple inequality filters on a given property, an entity will match the query only if at least one of its individual values for the property satisfies <span class="emphasis" id="-q2vm5v_345">all</span> of the filters. For example, if an entity of kind <code class="code" id="-q2vm5v_346">Widget</code> has values <code class="code" id="-q2vm5v_347">1</code> and <code class="code" id="-q2vm5v_348">2</code> for property <code class="code" id="-q2vm5v_349">x</code>, it will <span class="emphasis" id="-q2vm5v_350">not</span> match the query:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Widget&quot;)
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.GREATER_THAN, 1))
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.LESS_THAN, 2));
</div><p id="-q2vm5v_331">Each of the entity's <code class="code" id="-q2vm5v_351">x</code> values satisfies one of the filters, but neither single value satisfies both. Note that this does not apply to equality filters. For example, the same entity <span class="emphasis" id="-q2vm5v_352">will</span> satisfy the query</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Widget&quot;)
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.EQUAL, 1))
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.EQUAL, 2));
</div><p id="-q2vm5v_333">even though neither of the entity's individual <code class="code" id="-q2vm5v_353">x</code> values satisfies both filter conditions.</p><p id="-q2vm5v_334">The <code class="code" id="-q2vm5v_354">NOT_EQUAL</code> operator works as a &quot;value is other than&quot; test. So, for example, the query</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Widget&quot;)
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.NOT_EQUAL, 1));
</div><p id="-q2vm5v_336">matches any <code class="code" id="-q2vm5v_355">Widget</code> entity with an <code class="code" id="-q2vm5v_356">x</code> value other than <code class="code" id="-q2vm5v_357">1</code>.</p><p id="-q2vm5v_337">In Java, you can also use a query like</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Widget&quot;)
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.NOT_EQUAL, 1))
  .setFilter(new FilterPredicate(&quot;x&quot;, FilterOperator.NOT_EQUAL, 2));
</div><p id="-q2vm5v_339">which acts like</p><div class="code-block" data-lang="none">
x &lt; 1 OR (x &gt; 1 AND x &lt; 2) OR x &gt; 2
</div><p id="-q2vm5v_341">so a <code class="code" id="-q2vm5v_358">Widget</code> entity with <code class="code" id="-q2vm5v_359">x</code> values <code class="code" id="-q2vm5v_360">1</code>, <code class="code" id="-q2vm5v_361">2</code>, and <code class="code" id="-q2vm5v_362">3</code> matches, but one with values <code class="code" id="-q2vm5v_363">1</code> and <code class="code" id="-q2vm5v_364">2</code> does not.</p><p id="-q2vm5v_342">Similarly, the sort order for multiple-valued properties is unusual. Because such properties appear once in the index for each unique value, the first value seen in the index determines an entity's sort order:</p><ul class="list _bullet" id="-q2vm5v_343"><li class="list__item" id="-q2vm5v_365"><p id="-q2vm5v_368">If the query results are sorted in ascending order, the smallest value of the property is used for ordering.</p></li><li class="list__item" id="-q2vm5v_366"><p id="-q2vm5v_369">If the results are sorted in descending order, the greatest value is used for ordering.</p></li><li class="list__item" id="-q2vm5v_367"><p id="-q2vm5v_370">Other values do not affect the sort order, nor does the number of values.</p></li></ul><p id="-q2vm5v_344">This has the unusual consequence that an entity with property values <code class="code" id="-q2vm5v_371">1</code> and <code class="code" id="-q2vm5v_372">9</code> precedes one with values <code class="code" id="-q2vm5v_373">4</code>, <code class="code" id="-q2vm5v_374">5</code>, <code class="code" id="-q2vm5v_375">6</code>, and <code class="code" id="-q2vm5v_376">7</code> in both ascending <span class="emphasis" id="-q2vm5v_377">and</span> descending order.</p></section><section class="chapter"><h3 id="queries-inside-transactions-must-include-ancestor-filters" data-toc="queries-inside-transactions-must-include-ancestor-filters">Queries inside transactions must include ancestor filters</h3><p id="-q2vm5v_378">Datastore <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/transactions" id="-q2vm5v_379" data-external="true" rel="noopener noreferrer" target="_blank">transactions</a> operate only on entities belonging to the same <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/#Java_Ancestor_paths" id="-q2vm5v_380" data-external="true" rel="noopener noreferrer" target="_blank">entity group</a> (descended from a common ancestor). To preserve this restriction, all queries performed within a transaction must include an <span id="-q2vm5v_381">ancestor filter</span> specifying an ancestor in the same entity group as the other operations in the transaction.</p></section></section><section class="chapter"><h2 id="retrieving-results" data-toc="retrieving-results">Retrieving results</h2><p id="-q2vm5v_382">After constructing a query, you can specify a number of retrieval options to further control the results it returns.</p><p id="-q2vm5v_383">To retrieve just a single entity matching your query, use the method <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asSingleEntity()" id="-q2vm5v_392" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_393">PreparedQuery.asSingleEntity()</code></a>:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
  .setFilter(new FilterPredicate(&quot;lastName&quot;,
                                 FilterOperator.EQUAL,
                                 targetLastName));

PreparedQuery pq = datastore.prepare(q);
Entity result = pq.asSingleEntity();
</div><p id="-q2vm5v_385">This returns the first result found in the index that matches the query. (If there is more than one matching result, it throws a <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery.TooManyResultsException" id="-q2vm5v_394" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_395">TooManyResultsException</code></a>.</p><p id="-q2vm5v_386">To retrieve only selected properties of an entity rather than the entire entity, use a <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/projectionqueries" id="-q2vm5v_396" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-q2vm5v_397">projection query</span></a>. This type of query runs faster and costs less than one that returns complete entities.</p><p id="-q2vm5v_387">Similarly, a <span id="-q2vm5v_398"><span class="emphasis" id="-q2vm5v_400">keys-only query</span></span> saves time and resources by returning just the keys to the entities it matches, rather than the full entities themselves. To create this type of query, use the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query#setKeysOnly()" id="-q2vm5v_399" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_401">Query.setKeysOnly()</code></a> method:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .setKeysOnly();
</div><p id="-q2vm5v_389">You can specify a <span class="emphasis" id="-q2vm5v_402">limit</span> for your query to control the maximum number of results returned in one batch. The following example retrieves the five tallest people from the Datastore:</p><div class="code-block" data-lang="none">
List&lt;Entity&gt; getTallestPeople() {
  DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

  Query q = new Query(&quot;Person&quot;)
                  .addSort(&quot;height&quot;, SortDirection.DESCENDING);

  PreparedQuery pq = datastore.prepare(q);
  return pq.asList(FetchOptions.Builder.withLimit(5));
}
</div><p id="-q2vm5v_391">When iterating through the results of a query using the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asIterable()" id="-q2vm5v_403" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_406">PreparedQuery.asIterable()</code></a> and <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asIterator()" id="-q2vm5v_404" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_407">PreparedQuery.asIterator()</code></a> methods, the Datastore retrieves the results in batches. By default each batch contains 20 results, but you can change this value using <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/FetchOptions#chunkSize(int)" id="-q2vm5v_405" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_408">FetchOptions.chunkSize()</code></a>. You can continue iterating through query results until all are returned or the request times out.</p></section><section class="chapter"><h2 id="offsets-versus-cursors" data-toc="offsets-versus-cursors">Offsets versus cursors</h2><p id="-q2vm5v_409"><span class="control" id="-q2vm5v_410">Although Datastore supports integer offsets, you should avoid using them.</span> Instead, use cursors. Using an offset only avoids returning the skipped entities to your application, but these entities are still retrieved internally. The skipped entities do affect the latency of the query, and your application is billed for the read operations required to retrieve them. Using cursors instead of offsets lets you avoid all these costs.</p></section><section class="chapter"><h2 id="query-cursors" data-toc="query-cursors">Query cursors</h2><p id="-q2vm5v_411"><span class="emphasis" id="-q2vm5v_418">Query cursors</span> allow an application to retrieve a query's results in convenient batches without incurring the overhead of a query offset. After performing a <span id="-q2vm5v_419">retrieval operation</span>, the application can obtain a cursor, which is an opaque base64-encoded string marking the index position of the last result retrieved. The application can save this string (for instance in the Datastore, in Memcache, in a Task Queue task payload, or embedded in a web page as an HTTP <code class="code" id="-q2vm5v_420">GET</code> or <code class="code" id="-q2vm5v_421">POST</code> parameter), and can then use the cursor as the starting point for a subsequent retrieval operation to obtain the next batch of results from the point where the previous retrieval ended. A retrieval can also specify an end cursor, to limit the extent of the result set returned.</p><p id="-q2vm5v_412">In the low-level Java API, the application can use cursors via the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/QueryResultList" id="-q2vm5v_422" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_434">QueryResultList</code></a>, <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/QueryResultIterable" id="-q2vm5v_423" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_435">QueryResultIterable</code></a>, and <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/QueryResultIterator" id="-q2vm5v_424" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_436">QueryResultIterator</code></a> interfaces, which are returned by the <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery" id="-q2vm5v_425" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_437">PreparedQuery</code></a> methods <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asQueryResultList(com.google.appengine.api.datastore.FetchOptions)" id="-q2vm5v_426" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_438">asQueryResultList()</code></a>, <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asQueryResultIterable()" id="-q2vm5v_427" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_439">asQueryResultIterable()</code></a>, and <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asQueryResultIterator()" id="-q2vm5v_428" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_440">asQueryResultIterator()</code></a>, respectively. Each of these result objects provides a <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/QueryResultIterator#getCursor()" id="-q2vm5v_429" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_441">getCursor()</code></a> method, which in turn returns a <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Cursor" id="-q2vm5v_430" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_442">Cursor</code></a> object. The application can get a web-safe string representing the cursor by calling the <code class="code" id="-q2vm5v_431">Cursor</code> object's <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Cursor#toWebSafeString()" id="-q2vm5v_432" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_443">toWebSafeString()</code></a> method, and can later use the static method <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Cursor#fromWebSafeString(java.lang.String)" id="-q2vm5v_433" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_444">Cursor.fromWebSafeString()</code></a> to reconstitute the cursor from the string.</p><p id="-q2vm5v_413">The following example demonstrates the use of cursors for pagination:</p><div class="code-block" data-lang="none">
import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.QueryResultList;


public class ListPeopleServlet extends HttpServlet {

  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                   throws ServletException, IOException {

    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    
    resp.setContentType(&quot;text/html&quot;);
    resp.getWriter().println(&quot;&lt;ul&gt;&quot;);

    int pageSize = 15;
    FetchOptions fetchOptions = FetchOptions.Builder.withLimit(pageSize);
    String startCursor = req.getParameter(&quot;cursor&quot;);
    
    // If this servlet is passed a cursor parameter, let's use it
    if (startCursor != null) {
      fetchOptions.startCursor(Cursor.fromWebSafeString(startCursor));
    }
    
    Query q = new Query(&quot;Person&quot;);
    PreparedQuery pq = datastore.prepare(q);
    
    QueryResultList&lt;Entity&gt; results = pq.asQueryResultList(fetchOptions);
    for (Entity entity : results) {
      resp.getWriter().println(&quot;&lt;li&gt;&quot; + entity.getProperty(&quot;name&quot;) + &quot;&lt;/li&gt;&quot;);
    }
    resp.getWriter().println(&quot;&lt;/ul&gt;&quot;);
   
    String cursorString = results.getCursor().toWebSafeString();
    
    // Assuming this servlet lives at '/people'
    resp.getWriter().println(
      &quot;&lt;a href='/people?cursor=&quot; + cursorString + &quot;'&gt;Next page&lt;/a&gt;&quot;);
  }
}
</div><p id="-q2vm5v_415"><span class="control" id="-q2vm5v_445">Caution:</span> Be careful when passing a Datastore cursor to a client, such as in a web form. Although the client cannot change the cursor value to access results outside of the original query, it is possible for it to decode the cursor to expose information about result entities, such as the application ID, entity kind, key name or numeric ID, ancestor keys, and properties used in the query's filters and sort orders. If you don't want users to have access to that information, you can encrypt the cursor, or store it and provide the user with an opaque key.</p><section class="chapter"><h3 id="limitations-of-cursors" data-toc="limitations-of-cursors">Limitations of cursors</h3><p id="-q2vm5v_446">Cursors are subject to the following limitations:</p><ul class="list _bullet" id="-q2vm5v_447"><li class="list__item" id="-q2vm5v_448"><p id="-q2vm5v_452">A cursor can be used only by the same application that performed the original query, and only to continue the same query. To use the cursor in a subsequent retrieval operation, you must reconstitute the original query exactly, including the same entity kind, ancestor filter, property filters, and sort orders. It is not possible to retrieve results using a cursor without setting up the same query from which it was originally generated.</p></li><li class="list__item" id="-q2vm5v_449"><p id="-q2vm5v_453">Because the <code class="code" id="-q2vm5v_454">NOT_EQUAL</code> and <code class="code" id="-q2vm5v_455">IN</code> operators are implemented with multiple queries, queries that use them do not support cursors, nor do composite queries constructed with the <code class="code" id="-q2vm5v_456">CompositeFilterOperator.or</code> method.</p></li><li class="list__item" id="-q2vm5v_450"><p id="-q2vm5v_457">Cursors don't always work as expected with a query that uses an inequality filter or a sort order on a property with multiple values. The de-duplication logic for such multiple-valued properties does not persist between retrievals, possibly causing the same result to be returned more than once.</p></li><li class="list__item" id="-q2vm5v_451"><p id="-q2vm5v_458">New App Engine releases may change internal implementation details, invalidating cursors that depend on them. If an application attempts to use a cursor that is no longer valid, the Datastore raises an <a href="https://web.archive.org/web/20160424230618/http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html" id="-q2vm5v_459" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_462">IllegalArgumentException</code></a> (low-level API), <a href="//web.archive.org/web/20160424230618/https://db.apache.org/jdo/api20/apidocs/javax/jdo/JDOFatalUserException.html" id="-q2vm5v_460" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_463">JDOFatalUserException</code></a> (JDO), or <a href="https://web.archive.org/web/20160424230618/http://docs.oracle.com/javaee/6/api/javax/persistence/PersistenceException.html" id="-q2vm5v_461" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_464">PersistenceException</code></a> (JPA).</p></li></ul></section><section class="chapter"><h3 id="cursors-and-data-updates" data-toc="cursors-and-data-updates">Cursors and data updates</h3><p id="-q2vm5v_465">The cursor's position is defined as the location in the result list after the last result returned. A cursor is not a relative position in the list (it's not an offset); it's a marker to which the Datastore can jump when starting an index scan for results. If the results for a query change between uses of a cursor, the query notices only changes that occur in results after the cursor. If a new result appears before the cursor's position for the query, it will not be returned when the results after the cursor are fetched. Similarly, if an entity is no longer a result for a query but had appeared before the cursor, the results that appear after the cursor do not change. If the last result returned is removed from the result set, the cursor still knows how to locate the next result.</p><p id="-q2vm5v_466">When retrieving query results, you can use both a start cursor and an end cursor to return a continuous group of results from the Datastore. When using a start and end cursor to retrieve the results, you are not guaranteed that the size of the results will be the same as when you generated the cursors. Entities may be added or deleted from the Datastore between the time the cursors are generated and when they are used in a query.</p></section></section><section class="chapter"><h2 id="data-consistency" data-toc="data-consistency">Data consistency</h2><p id="-q2vm5v_467">Datastore queries can deliver their results at either of two consistency levels:</p><ul class="list _bullet" id="-q2vm5v_468"><li class="list__item" id="-q2vm5v_476"><p id="-q2vm5v_478"><a href="https://web.archive.org/web/20160424230618/https://en.wikipedia.org/wiki/Strong_consistency" id="-q2vm5v_479" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-q2vm5v_480">Strongly consistent</span></a> queries guarantee the freshest results, but may take longer to complete.</p></li><li class="list__item" id="-q2vm5v_477"><p id="-q2vm5v_481"><a href="https://web.archive.org/web/20160424230618/https://en.wikipedia.org/wiki/Eventual_consistency" id="-q2vm5v_482" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-q2vm5v_483">Eventually consistent</span></a> queries generally run faster, but may occasionally return stale results.</p></li></ul><p id="-q2vm5v_469">In an eventually consistent query, the indexes used to gather the results are also accessed with eventual consistency. Consequently, such queries may sometimes return entities that no longer match the original query criteria, while strongly consistent queries are always transactionally consistent. See the article <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/articles/transaction_isolation" id="-q2vm5v_484" data-external="true" rel="noopener noreferrer" target="_blank">Transaction Isolation in App Engine</a> for more information on how entities and indexes are updated.</p><p id="-q2vm5v_470">Queries return their results with different levels of consistency guarantee, depending on the nature of the query:</p><ul class="list _bullet" id="-q2vm5v_471"><li class="list__item" id="-q2vm5v_485"><p id="-q2vm5v_487"><span id="-q2vm5v_488">Ancestor queries</span> (those within an <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Ancestor_paths" id="-q2vm5v_489" data-external="true" rel="noopener noreferrer" target="_blank">entity group</a>) are strongly consistent by default, but can instead be made eventually consistent by setting the Datastore read policy (see below).</p></li><li class="list__item" id="-q2vm5v_486"><p id="-q2vm5v_490">Non-ancestor queries are always eventually consistent.</p></li></ul><p id="-q2vm5v_472">To improve performance, you can set the Datastore <span class="emphasis" id="-q2vm5v_491">read policy</span> so that all reads and queries are eventually consistent. (The API also allows you to explicitly set a strong consistency policy, but this setting will have no practical effect, since non-ancestor queries are always eventually consistent regardless of policy.)</p><p id="-q2vm5v_473">You can also set the Datastore <span class="emphasis" id="-q2vm5v_492">call deadline:</span> the maximum time, in seconds, that the application will wait for the Datastore to return a result before aborting with an error. The default deadline is 60 seconds; it is not currently possible to set it higher, but you can adjust it downward to ensure that a particular operation fails quickly (for instance, to return a faster response to the user).</p><p id="-q2vm5v_474">To set the Datastore read policy in Java, you construct a <span class="emphasis" id="-q2vm5v_493">Datastore service configuration</span> (<a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreServiceConfig" id="-q2vm5v_494" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_497">DatastoreServiceConfig</code></a>), using the nested helper class <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreServiceConfig.Builder" id="-q2vm5v_495" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_498">DatastoreServiceConfig.Builder</code></a>, and pass it an instance of class <a href="https://web.archive.org/web/20160424230618/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/ReadPolicy" id="-q2vm5v_496" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-q2vm5v_499">ReadPolicy</code></a>. The following example shows how to set the read policy, the call deadline, or both:</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceConfig;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.ReadPolicy.Consistency;


double deadline = 5.0;

// Construct a read policy for eventual consistency
ReadPolicy policy = new ReadPolicy(ReadPolicy.Consistency.EVENTUAL);
    
// Set the read policy
DatastoreServiceConfig eventuallyConsistentConfig =
                         DatastoreServiceConfig.Builder.withReadPolicy(policy);
    
// Set the call deadline
DatastoreServiceConfig deadlineConfig =
                         DatastoreServiceConfig.Builder.withDeadline(deadline);
    
// Set both the read policy and the call deadline
DatastoreServiceConfig datastoreConfig =
      DatastoreServiceConfig.Builder.withReadPolicy(policy).deadline(deadline);
    
// Get Datastore service with the given configuration
DatastoreService datastore =
                   DatastoreServiceFactory.getDatastoreService(datastoreConfig);
</div></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="entities-properties-and-keys.html" class="navigation-links__prev">Entities, Properties, and Keys</a><a href="geospatial-queries.html" class="navigation-links__next">Geospatial Queries</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>