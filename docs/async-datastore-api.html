<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:44.095219666"><title>Async Datastore API | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"working-with-the-async-datastore-service","level":0,"title":"Working with the Async Datastore Service","anchor":"#working-with-the-async-datastore-service"},{"id":"working-with-async-transactions","level":0,"title":"Working with Async Transactions","anchor":"#working-with-async-transactions"},{"id":"working-with-futures","level":0,"title":"Working with Futures","anchor":"#working-with-futures"},{"id":"async-queries","level":0,"title":"Async Queries","anchor":"#async-queries"},{"id":"when-to-use-async-datastore-calls","level":0,"title":"When To Use Async Datastore Calls","anchor":"#when-to-use-async-datastore-calls"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Async Datastore API | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/async-datastore-api.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Async Datastore API | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/async-datastore-api.html#webpage",
    "url": "writerside-documentation/async-datastore-api.html",
    "name": "Async Datastore API | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Async-Datastore-API" data-main-title="Async Datastore API" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Google-Cloud-Datastore.md|Google Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Async-Datastore-API" id="Async-Datastore-API.md">Async Datastore API</h1><p id="z4jvcq2_3">The Async Datastore API allows you to make parallel, non-blocking calls to the datastore and to retrieve the results of these calls at a later point in the handling of the request. This documentation describes the following aspects of the Async Datastore API:</p><ol class="list _decimal" id="z4jvcq2_4" type="1"><li class="list__item" id="z4jvcq2_10"><p id="z4jvcq2_15"><span id="z4jvcq2_16">Working with the Async Datastore Service</span></p></li><li class="list__item" id="z4jvcq2_11"><p id="z4jvcq2_17"><span id="z4jvcq2_18">Working with Async Transactions</span></p></li><li class="list__item" id="z4jvcq2_12"><p id="z4jvcq2_19"><span id="z4jvcq2_20">Working with Futures</span></p></li><li class="list__item" id="z4jvcq2_13"><p id="z4jvcq2_21"><span id="z4jvcq2_22">Async Queries</span></p></li><li class="list__item" id="z4jvcq2_14"><p id="z4jvcq2_23"><span id="z4jvcq2_24">When To Use Async Datastore Calls</span></p></li></ol><section class="chapter"><h2 id="working-with-the-async-datastore-service" data-toc="working-with-the-async-datastore-service">Working with the Async Datastore Service</h2><p id="z4jvcq2_25">With the async datastore API, you make datastore calls using methods of the <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService" id="z4jvcq2_32" data-external="true" rel="noopener noreferrer" target="_blank">AsyncDatastoreService</a> interface. You get this object by calling the <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreServiceFactory#getAsyncDatastoreService()" id="z4jvcq2_33" data-external="true" rel="noopener noreferrer" target="_blank">getAsyncDatastoreService()</a> class method of the <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreServiceFactory" id="z4jvcq2_34" data-external="true" rel="noopener noreferrer" target="_blank">DatastoreServiceFactory</a> class.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.AsyncDatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;

// ...
AsyncDatastoreService datastore = DatastoreServiceFactory.getAsyncDatastoreService();
</div><p id="z4jvcq2_27"><code class="code" id="z4jvcq2_35">AsyncDatastoreService</code> supports the same operations as <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreService" id="z4jvcq2_36" data-external="true" rel="noopener noreferrer" target="_blank">DatastoreService</a>, except most methods immediately return a <a href="https://web.archive.org/web/20160424225420/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html" id="z4jvcq2_37" data-external="true" rel="noopener noreferrer" target="_blank">Future</a> whose result you can block on at some later point. For example, <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreService#get(com.google.appengine.api.datastore.Key)" id="z4jvcq2_38" data-external="true" rel="noopener noreferrer" target="_blank">DatastoreService.get()</a> returns an <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Entity" id="z4jvcq2_39" data-external="true" rel="noopener noreferrer" target="_blank">Entity</a> but <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService#get(com.google.appengine.api.datastore.Key)" id="z4jvcq2_40" data-external="true" rel="noopener noreferrer" target="_blank">AsyncDatastoreService.get()</a> returns a <code class="code" id="z4jvcq2_41">Future&lt;Entity&gt;</code>.</p><div class="code-block" data-lang="none">
// ...

Key key = KeyFactory.createKey(&quot;Employee&quot;, &quot;Max&quot;);
// Async call returns immediately
Future&lt;Entity&gt; entityFuture = datastore.get(key);

// Do other stuff while the get operation runs in the background...

// Blocks if the get operation has not finished, otherwise returns instantly
Entity entity = entityFuture.get();
</div><p id="z4jvcq2_29"><span class="control" id="z4jvcq2_42">Note:</span> Exceptions are not thrown until you call the get() method. Calling this method allows you to verify that the asynchronous operation succeeded.</p><p id="z4jvcq2_30">If you have an <code class="code" id="z4jvcq2_43">AsyncDatastoreService</code> but need to execute an operation synchronously, invoke the appropriate <code class="code" id="z4jvcq2_44">AsyncDatastoreService</code> method and then immediately block on the result:</p><div class="code-block" data-lang="none">
// ...

Entity entity = new Employee(&quot;Employee&quot;, &quot;Alfred&quot;);
// ... populate entity properties

// Make a sync call via the async interface
Key key = datastore.put(key).get();
</div></section><section class="chapter"><h2 id="working-with-async-transactions" data-toc="working-with-async-transactions">Working with Async Transactions</h2><p id="z4jvcq2_45">Async datastore API calls can participate in transactions just like synchronous calls. Here's a function that adjusts the salary of an <code class="code" id="z4jvcq2_50">Employee</code> and writes an additional <code class="code" id="z4jvcq2_51">SalaryAdjustment</code> entity in the same entity group as the <code class="code" id="z4jvcq2_52">Employee</code>, all within a single transaction.</p><div class="code-block" data-lang="none">
void giveRaise(AsyncDatastoreService datastore, Key employeeKey, long raiseAmount)
        throws Exception {
    Future&lt;Transaction&gt; txn = datastore.beginTransaction();

    // Async call to lookup the Employee entity
    Future&lt;Entity&gt; employeeEntityFuture = datastore.get(employeeKey);

    // Create and put a SalaryAdjustment entity in parallel with the lookup
    Entity adjustmentEntity = new Entity(&quot;SalaryAdjustment&quot;, employeeKey);
    adjustmentEntity.setProperty(&quot;adjustment&quot;, raiseAmount);
    adjustmentEntity.setProperty(&quot;adjustmentDate&quot;, new Date());
    datastore.put(adjustmentEntity);

    // Fetch the result of our lookup to make the salary adjustment
    Entity employeeEntity = employeeEntityFuture.get();
    long salary = (Long) employeeEntity.getProperty(&quot;salary&quot;);
    employeeEntity.setProperty(&quot;salary&quot;, salary + raiseAmount);

    // Re-put the Employee entity with the adjusted salary.
    datastore.put(employeeEntity);
    txn.get().commit(); // could also call txn.get().commitAsync() here
}
</div><p id="z4jvcq2_47">This sample illustrates an important difference between async calls without transactions and async calls with transactions. When you are not using a transaction, the only way to ensure that an individual async call has completed is to fetch the return value of the <code class="code" id="z4jvcq2_53">Future</code> that was returned when the call was made. When you are using a transaction, calling <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Transaction#commit()" id="z4jvcq2_54" data-external="true" rel="noopener noreferrer" target="_blank">Transaction.commit()</a> blocks on the result of all async calls made since the transaction started before committing it.</p><p id="z4jvcq2_48">So, in our example above, even though our async call to insert the <code class="code" id="z4jvcq2_55">SalaryAdjustment</code> entity may still be outstanding when we call <code class="code" id="z4jvcq2_56">commit()</code>, the commit will not happen until the insert completes. Similarly, if you elect to call <code class="code" id="z4jvcq2_57">commitAsync()</code> instead of <code class="code" id="z4jvcq2_58">commit()</code>, invoking <code class="code" id="z4jvcq2_59">get()</code> on the <code class="code" id="z4jvcq2_60">Future</code> returned by <code class="code" id="z4jvcq2_61">commitAsync()</code> blocks until all oustanding async calls have completed.</p><p id="z4jvcq2_49"><span class="control" id="z4jvcq2_62">Note:</span> Transactions are associated with a specific thread, not a specific instance of <code class="code" id="z4jvcq2_63">DatastoreService</code> or <code class="code" id="z4jvcq2_64">AsyncDatastoreService</code>. This means that if you initiate a transaction with a <code class="code" id="z4jvcq2_65">DatastoreService</code> and perform an async call with an <code class="code" id="z4jvcq2_66">AsyncDatastoreService</code>, the async call participates in the transaction. Or, to put it more succinctly, <code class="code" id="z4jvcq2_67">DatastoreService.getCurrentTransaction()</code> and <code class="code" id="z4jvcq2_68">AsyncDatastoreService.getCurrentTransaction()</code> always returns the same <code class="code" id="z4jvcq2_69">Transaction</code>.</p></section><section class="chapter"><h2 id="working-with-futures" data-toc="working-with-futures">Working with Futures</h2><p id="z4jvcq2_70">The <a href="https://web.archive.org/web/20160424225420/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html" id="z4jvcq2_72" data-external="true" rel="noopener noreferrer" target="_blank">Future Javadoc</a> explains most of what you need to know to successfully work with a <code class="code" id="z4jvcq2_73">Future</code> returned by the Async Datastore API, but there are a few App Engine-specific things you need to be aware of:</p><ul class="list _bullet" id="z4jvcq2_71"><li class="list__item" id="z4jvcq2_74"><p id="z4jvcq2_76">When you call <a href="https://web.archive.org/web/20160424225420/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html#get(long,%20java.util.concurrent.TimeUnit)" id="z4jvcq2_77" data-external="true" rel="noopener noreferrer" target="_blank">Future.get(long timeout, TimeUnit unit)</a>, the timeout is separate from any RPC deadline set when you created the <code class="code" id="z4jvcq2_78">AsyncDatastoreService</code>. For more information, see the <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Data_consistency" id="z4jvcq2_79" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page.</p></li><li class="list__item" id="z4jvcq2_75"><p id="z4jvcq2_80">When you call <a href="https://web.archive.org/web/20160424225420/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html#cancel(boolean)" id="z4jvcq2_81" data-external="true" rel="noopener noreferrer" target="_blank">Future.cancel(boolean mayInterruptIfRunning)</a> and that call returns <code class="code" id="z4jvcq2_82">true</code>, that does not necessarily mean that the state of your datastore is unchanged. In other words, cancelling a <code class="code" id="z4jvcq2_83">Future</code> is not the same as rolling back a transaction.</p></li></ul></section><section class="chapter"><h2 id="async-queries" data-toc="async-queries">Async Queries</h2><p id="z4jvcq2_84">We do not currently expose an explicitly async API for queries. However, when you invoke <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asIterable()" id="z4jvcq2_86" data-external="true" rel="noopener noreferrer" target="_blank">PreparedQuery.asIterable()</a>, <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asIterator()" id="z4jvcq2_87" data-external="true" rel="noopener noreferrer" target="_blank">PreparedQuery.asIterator()</a> or <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreparedQuery#asList(com.google.appengine.api.datastore.FetchOptions)" id="z4jvcq2_88" data-external="true" rel="noopener noreferrer" target="_blank">PreparedQuery.asList(FetchOptions fetchOptions)</a>, both DatastoreService and AsyncDatastoreService immediately return and asynchronously prefetch results. This allows your application to perform work in parallel while query results are fetched.</p><div class="code-block" data-lang="none">
// ...

Query q1 = new Query(&quot;Salesperson&quot;);
q1.setFilter(new FilterPredicate(&quot;dateOfHire&quot;, FilterOperator.LESS_THAN, oneMonthAgo));

// Returns instantly, query is executing in the background.
Iterable&lt;Entity&gt; recentHires = datastore.prepare(q1).asIterable();

Query q2 = new Query(&quot;Customer&quot;);
q2.setFilter(new FilterPredicate(&quot;lastContact&quot;, FilterOperator.GREATER_THAN, oneYearAgo));

// Also returns instantly, query is executing in the background.
Iterable&lt;Entity&gt; needsFollowup = datastore.prepare(q2).asIterable();

schedulePhoneCall(recentHires, needsFollowUp);
</div></section><section class="chapter"><h2 id="when-to-use-async-datastore-calls" data-toc="when-to-use-async-datastore-calls">When To Use Async Datastore Calls</h2><p id="z4jvcq2_89">The operations exposed by the <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreService" id="z4jvcq2_94" data-external="true" rel="noopener noreferrer" target="_blank">DatastoreService</a> interface are synchronous. For example, when you call <code class="code" id="z4jvcq2_95">DatastoreService.get()</code>, your code blocks until the call to the datastore completes. If the only thing your application needs to do is render the result of the <code class="code" id="z4jvcq2_96">get()</code> in HTML, blocking until the call is complete is a perfectly reasonable thing to do. However, if your application needs the result of the <code class="code" id="z4jvcq2_97">get()</code> plus the result of a <code class="code" id="z4jvcq2_98">Query</code> to render the response, and if the <code class="code" id="z4jvcq2_99">get()</code> and the <code class="code" id="z4jvcq2_100">Query</code> don't have any data dependencies, then waiting until the <code class="code" id="z4jvcq2_101">get()</code> completes to initiate the <code class="code" id="z4jvcq2_102">Query</code> is a waste of time. Here is an example of some code that can be improved by using the async API:</p><div class="code-block" data-lang="none">
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
Key empKey = KeyFactory.createKey(&quot;Employee&quot;, &quot;Max&quot;);

// Read employee data from the Datastore
Entity employee = datastore.get(empKey); // Blocking for no good reason!

// Fetch payment history
Query query = new Query(&quot;PaymentHistory&quot;);
PreparedQuery pq = datastore.prepare(query);
List&lt;Entity&gt; result = pq.asList(FetchOptions.Builder.withLimit(10));
renderHtml(employee, result);
</div><p id="z4jvcq2_91">Instead of waiting for the <code class="code" id="z4jvcq2_103">get()</code> to complete, use an instance of <a href="https://web.archive.org/web/20160424225420/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService" id="z4jvcq2_104" data-external="true" rel="noopener noreferrer" target="_blank">AsyncDatastoreService</a> to execute the call asynchronously:</p><div class="code-block" data-lang="none">
AsyncDatastoreService datastore = DatastoreServiceFactory.getAsyncDatastoreService();
Key empKey = KeyFactory.createKey(&quot;Employee&quot;, &quot;Max&quot;);

// Read employee data from the Datastore
Future&lt;Entity&gt; employeeFuture = datastore.get(empKey); // Returns immediately!

// Fetch payment history for the employee
Query query = new Query(&quot;PaymentHistory&quot;, empKey);
PreparedQuery pq = datastore.prepare(query);

// Run the query while the employee is being fetched
List&lt;Entity&gt; result = pq.asList(FetchOptions.Builder.withLimit(10));
// Implicitly performs query asynchronously
Entity employee = employeeFuture.get(); // Blocking!
renderHtml(employee, result); 
</div><p id="z4jvcq2_93">The synchronous and asynchronous versions of this code use similar amounts of CPU (after all, they both perform the same amount of work), but since the asynchronous version allows the two datastore operations to execute in parallel, the asynchronous version has lower latency. In general, if you need to perform multiple datastore operations that don't have any data dependencies, the <code class="code" id="z4jvcq2_105">AsyncDatastoreService</code> can significantly improve latency.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="datastore-statistics-in-java.html" class="navigation-links__prev">Datastore Statistics in Java</a><a href="datastore-callbacks.html" class="navigation-links__next">Datastore Callbacks</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>