<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:44.136343331"><title>Datastore Callbacks | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"preput","level":0,"title":"PrePut","anchor":"#preput"},{"id":"postput","level":0,"title":"PostPut","anchor":"#postput"},{"id":"predelete","level":0,"title":"PreDelete","anchor":"#predelete"},{"id":"postdelete","level":0,"title":"PostDelete","anchor":"#postdelete"},{"id":"preget","level":0,"title":"PreGet","anchor":"#preget"},{"id":"prequery","level":0,"title":"PreQuery","anchor":"#prequery"},{"id":"postload","level":0,"title":"PostLoad","anchor":"#postload"},{"id":"batch-operations","level":0,"title":"Batch Operations","anchor":"#batch-operations"},{"id":"async-operations","level":0,"title":"Async Operations","anchor":"#async-operations"},{"id":"using-callbacks-with-app-engine-services","level":0,"title":"Using Callbacks With App Engine Services","anchor":"#using-callbacks-with-app-engine-services"},{"id":"common-errors-to-avoid","level":0,"title":"Common Errors To Avoid","anchor":"#common-errors-to-avoid"},{"id":"using-callbacks-with-eclipse","level":0,"title":"Using Callbacks With Eclipse","anchor":"#using-callbacks-with-eclipse"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Datastore Callbacks | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/datastore-callbacks.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Datastore Callbacks | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/datastore-callbacks.html#webpage",
    "url": "writerside-documentation/datastore-callbacks.html",
    "name": "Datastore Callbacks | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Datastore-Callbacks" data-main-title="Datastore Callbacks" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Google-Cloud-Datastore.md|Google Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Datastore-Callbacks" id="Datastore-Callbacks.md">Datastore Callbacks</h1><p id="-w650wr_3">A callback allows you to execute code at various points in the persistence process. You can use these callbacks to easily implement cross-functional logic like logging, sampling, decoration, auditing, and validation (among other things). The Datastore API currently supports callbacks that execute before and after <code class="code" id="-w650wr_17">put()</code> and <code class="code" id="-w650wr_18">delete()</code> operations.</p><ol class="list _decimal" id="-w650wr_4" type="1"><li class="list__item" id="-w650wr_19"><p id="-w650wr_31"><span id="-w650wr_32">PrePut</span></p></li><li class="list__item" id="-w650wr_20"><p id="-w650wr_33"><span id="-w650wr_34">PostPut</span></p></li><li class="list__item" id="-w650wr_21"><p id="-w650wr_35"><span id="-w650wr_36">PreDelete</span></p></li><li class="list__item" id="-w650wr_22"><p id="-w650wr_37"><span id="-w650wr_38">PostDelete</span></p></li><li class="list__item" id="-w650wr_23"><p id="-w650wr_39"><span id="-w650wr_40">PreGet</span></p></li><li class="list__item" id="-w650wr_24"><p id="-w650wr_41"><span id="-w650wr_42">PreQuery</span></p></li><li class="list__item" id="-w650wr_25"><p id="-w650wr_43"><span id="-w650wr_44">PostLoad</span></p></li><li class="list__item" id="-w650wr_26"><p id="-w650wr_45"><span id="-w650wr_46">Batch Operations</span></p></li><li class="list__item" id="-w650wr_27"><p id="-w650wr_47"><span id="-w650wr_48">Async Operations</span></p></li><li class="list__item" id="-w650wr_28"><p id="-w650wr_49"><span id="-w650wr_50">Using Callbacks With App Engine Services</span></p></li><li class="list__item" id="-w650wr_29"><p id="-w650wr_51"><span id="-w650wr_52">Common Errors To Avoid</span></p></li><li class="list__item" id="-w650wr_30"><p id="-w650wr_53"><span id="-w650wr_54">Using Callbacks With Eclipse</span></p></li></ol><section class="chapter"><h2 id="preput" data-toc="preput">PrePut</h2><p id="-w650wr_55">When you register a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PrePut" id="-w650wr_58" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_59">PrePut</code></a> callback with a specific kind, the callback will be invoked before any entity of that kind is put (or, if no kind is provided, before any entity is put):</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PutContext;
import java.util.Date;
import java.util.logging.Logger;

class PrePutCallbacks {
    static Logger logger = Logger.getLogger(&quot;callbacks&quot;);

    @PrePut(kinds = {&quot;Customer&quot;, &quot;Order&quot;})
    void log(PutContext context) {
        logger.fine(&quot;Putting &quot; + context.getCurrentElement().getKey());
    }

    @PrePut // Applies to all kinds
    void updateTimestamp(PutContext context) {
        context.getCurrentElement().setProperty(&quot;last_updated&quot;, new Date());
    }
}
</div><p id="-w650wr_57">A method annotated with <code class="code" id="-w650wr_60">PrePut</code> must be an instance method that returns <code class="code" id="-w650wr_61">void</code>, accepts a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PutContext" id="-w650wr_62" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_65">PutContext</code></a> as its only argument, does not throw any checked exceptions, and belongs to a class with a no-arg constructor. When a <code class="code" id="-w650wr_63">PrePut</code> callback throws an exception, no further callbacks are executed, and the <code class="code" id="-w650wr_64">put()</code> operation throws the exception before any RPCs are issued to the datastore.</p></section><section class="chapter"><h2 id="postput" data-toc="postput">PostPut</h2><p id="-w650wr_66">When you register a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PostPut" id="-w650wr_69" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_70">PostPut</code></a> callback with a specific kind, the callback will be invoked after any entity of that kind is put (or, if no kind is provided, after any entity is put).</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PostPut;
import com.google.appengine.api.datastore.PutContext;
import java.util.logging.Logger;

class PostPutCallbacks {
    static Logger logger = Logger.getLogger(&quot;logger&quot;);

    @PostPut(kinds = {&quot;Customer&quot;, &quot;Order&quot;}) // Only applies to Customers and Orders
    void log(PutContext context) {
        logger.fine(&quot;Finished putting &quot; + context.getCurrentElement().getKey());
    }

    @PostPut // Applies to all kinds
    void collectSample(PutContext context) {
        Sampler.getSampler().collectSample(
            &quot;put&quot;, context.getCurrentElement().getKey());
    }
}
</div><p id="-w650wr_68">A method annotated with <code class="code" id="-w650wr_71">PostPut</code> must be an instance method that returns <code class="code" id="-w650wr_72">void</code>, accepts a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PutContext" id="-w650wr_73" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_80">PutContext</code></a> as its only argument, does not throw any checked exceptions, and belongs to a class with a no-arg constructor. When a <code class="code" id="-w650wr_74">PostPut</code> callback throws an exception, no further callbacks are executed but the result of the <code class="code" id="-w650wr_75">put()</code> operation is unaffected. Note that if the <code class="code" id="-w650wr_76">put()</code> operation itself fails, <code class="code" id="-w650wr_77">PostPut</code> callbacks will not be invoked at all. Also, <code class="code" id="-w650wr_78">PostPut</code> callbacks that are associated with transactional <code class="code" id="-w650wr_79">put()</code> operations will not run until the transaction successfully commits.</p></section><section class="chapter"><h2 id="predelete" data-toc="predelete">PreDelete</h2><p id="-w650wr_81">When you register a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreDelete" id="-w650wr_84" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_85">PreDelete</code></a> callback with a specific kind, the callback will be invoked before any entity of that kind is deleted (or, if no kind is provided, before any entity is deleted):</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DeleteContext;
import com.google.appengine.api.datastore.PreDelete;
import java.util.logging.Logger;

class PreDeleteCallbacks {
    static Logger logger = Logger.getLogger(&quot;logger&quot;);

    @PreDelete(kinds = {&quot;Customer&quot;, &quot;Order&quot;})
    void checkAccess(DeleteContext context) {
        if (!Auth.canDelete(context.getCurrentElement()) {
            throw new SecurityException();
        }
    }

    @PreDelete // Applies to all kinds
    void log(DeleteContext context) {
        logger.fine(&quot;Deleting &quot; + context.getCurrentElement().getKey());
    }
}
</div><p id="-w650wr_83">A method annotated with <code class="code" id="-w650wr_86">PreDelete</code> must be an instance method that returns <code class="code" id="-w650wr_87">void</code>, accepts a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DeleteContext" id="-w650wr_88" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_91">DeleteContext</code></a> as its only argument, does not throw any checked exceptions, and belongs to a class with a no-arg constructor. When a <code class="code" id="-w650wr_89">PreDelete</code> callback throws an exception, no further callbacks are executed and the <code class="code" id="-w650wr_90">delete()</code> operation throws the exception before any RPCs are issued to the datastore.</p></section><section class="chapter"><h2 id="postdelete" data-toc="postdelete">PostDelete</h2><p id="-w650wr_92">When you register a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PostDelete" id="-w650wr_95" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_96">PostDelete</code></a> callback with a specific kind, the callback will be invoked after any entity of that kind is deleted (or, if no kind is provided, after any entity is deleted):</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DeleteContext;
import com.google.appengine.api.datastore.PostDelete;
import java.util.logging.Logger;

class PostDeleteCallbacks {
    static Logger logger = Logger.getLogger(&quot;logger&quot;);

    @PostDelete(kinds = {&quot;Customer&quot;, &quot;Order&quot;})
    void log(DeleteContext context) {
        logger.fine(
            &quot;Finished deleting &quot; + context.getCurrentElement().getKey());
    }

    @PostDelete // Applies to all kinds
    void collectSample(DeleteContext context) {
        Sampler.getSampler().collectSample(
            &quot;delete&quot;, context.getCurrentElement().getKey());
    }
}
</div><p id="-w650wr_94">A method annotated with <code class="code" id="-w650wr_97">PostDelete</code> must be an instance method that returns <code class="code" id="-w650wr_98">void</code>, accepts a <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DeleteContext" id="-w650wr_99" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_106">DeleteContext</code></a> as its only argument, does not throw any checked exceptions, and belongs to a class with a no-arg constructor. When a <code class="code" id="-w650wr_100">PostDelete</code> callback throws an exception, no further callbacks are executed but the result of the <code class="code" id="-w650wr_101">delete()</code> operation is unaffected. Note that if the <code class="code" id="-w650wr_102">delete()</code> operation itself fails, <code class="code" id="-w650wr_103">PostDelete</code> callbacks will not be invoked at all. Also, <code class="code" id="-w650wr_104">PostDelete</code> callbacks that are associated with transactional <code class="code" id="-w650wr_105">delete()</code> operations will not run until the transaction successfully commits.</p></section><section class="chapter"><h2 id="preget" data-toc="preget">PreGet</h2><p id="-w650wr_107">You can register a <code class="code" id="-w650wr_109"></code><a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreGet" id="-w650wr_110" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_111">PreGet</code></a> callback to be called before getting entities of some specific kinds (or all kinds). You might use this, for example, to intercept some get requests and fetch the data from a cache instead of from the datastore.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PreGetContext;
import com.google.appengine.api.datastore.PreGet;

class PreGetCallbacks {
  @PreGet(kinds = {&quot;Customer&quot;, &quot;Order&quot;})
  public void preGet(PreGetContext context) {
    Entity e = MyCache.get(context.getCurrentElement());
    if (e != null) {
      context.setResultForCurrentElement(e);
    }
    // if not in cache, don't set result; let the normal datastore-fetch happen
  }
}
</div></section><section class="chapter"><h2 id="prequery" data-toc="prequery">PreQuery</h2><p id="-w650wr_112">You can register a <code class="code" id="-w650wr_114"></code><a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PreQuery" id="-w650wr_115" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_116">PreQuery</code></a> callback to be called before executing queries for specific kinds (or all kinds). You might use this, for example, to add an equality filter based on the logged in user. The callback is passed the query; by modifying it, the callback can cause a different query to be executed instead. Or the callback can throw an unchecked exception to prevent the query from being executed.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PreQueryContext;
import com.google.appengine.api.datastore.PreQuery;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;

class PreQueryCallbacks {
  @PreQuery(kinds = {&quot;Customer&quot;})
  // Queries should only return data owned by the logged in user.
  public void preQuery(PreQueryContext context) {
    UserService users = UserServiceFactory.getUserService();
    context.getCurrentElement().setFilter(
        new FilterPredicate(&quot;owner&quot;, Query.FilterOperator.EQUAL, users.getCurrentUser()));
    }
}
</div></section><section class="chapter"><h2 id="postload" data-toc="postload">PostLoad</h2><p id="-w650wr_117">You can register a <code class="code" id="-w650wr_119"></code><a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PostLoad" id="-w650wr_120" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_121">PostLoad</code></a> callback to be called after loading entities of specific kinds (or all kinds). Here, &quot;loading&quot; might mean the result of a get or a query. This is useful for decorating loaded entities.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PostLoadContext;
import com.google.appengine.api.datastore.PostLoad;

class PostLoadCallbacks {
   @PostLoad(kinds = {&quot;Order&quot;})
   public void postLoad(PostLoadContext context) {
     context.getCurrentElement().setProperty(&quot;read_timestamp&quot;,
                                             System.currentTimeMillis());
   }
}
</div></section><section class="chapter"><h2 id="batch-operations" data-toc="batch-operations">Batch Operations</h2><p id="-w650wr_122">When you execute a batch operation (a <code class="code" id="-w650wr_126">put()</code> with multiple entities for example), your callbacks are invoked once per entity. You can access the entire batch of objects by calling <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/CallbackContext#getElements()" id="-w650wr_127" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_128">CallbackContext.getElements()</code></a> on the argument to your callback method. This allows you to implement callbacks that operate on the entire batch instead of one element at a time.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PutContext;

class Validation {
    @PrePut(kinds = &quot;TicketOrder&quot;)
    void checkBatchSize(PutContext context) {
        if (context.getElements().size() &gt; 5) {
            throw new IllegalArgumentException(
                &quot;Cannot purchase more than 5 tickets at once.&quot;);
        }
    }
}
</div><p id="-w650wr_124">If you need your callback to only execute once per batch, use <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/CallbackContext#getCurrentIndex()" id="-w650wr_129" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_130">CallbackContext.getCurrentIndex()</code></a> to determine if you're looking at the first element of the batch.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PutContext;
import java.util.logging.Logger;

class Validation {
    static Logger logger = Logger.getLogger(&quot;logger&quot;);

    @PrePut
    void log(PutContext context) {
        if (context.getCurrentIndex() == 0) {
            logger.fine(&quot;Putting batch of size &quot; + getElements().size());
        }
    }
}
</div></section><section class="chapter"><h2 id="async-operations" data-toc="async-operations">Async Operations</h2><p id="-w650wr_131">There are a few important things to know about how callbacks interact with async datastore operations. When you execute a <code class="code" id="-w650wr_132">put()</code> or a <code class="code" id="-w650wr_133">delete()</code> using the <a href="https://web.archive.org/web/20160424230753/https://cloud.google.com/appengine/docs/java/datastore/async" id="-w650wr_134" data-external="true" rel="noopener noreferrer" target="_blank">async datastore API</a>, any <code class="code" id="-w650wr_135">Pre*</code> callbacks that you've registered will execute synchronously. Your <code class="code" id="-w650wr_136">Post*</code> callbacks will execute synchronously as well, but not until you call any of the <a href="https://web.archive.org/web/20160424230753/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html#get()" id="-w650wr_137" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_138">Future.get()</code></a> methods to retrieve the result of the operation.</p></section><section class="chapter"><h2 id="using-callbacks-with-app-engine-services" data-toc="using-callbacks-with-app-engine-services">Using Callbacks With App Engine Services</h2><p id="-w650wr_139">Callbacks, like any other code in your application, have access to the full range of App Engine backend services, and you can define as many as you want in a single class.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.DeleteContext;
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PostPut;
import com.google.appengine.api.datastore.PostDelete;
import com.google.appengine.api.datastore.PutContext;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.urlfetch.URLFetchService;
import com.google.appengine.api.urlfetch.URLFetchServiceFactory;

class ManyCallbacks {

    @PrePut(kinds = {&quot;kind1&quot;, &quot;kind2&quot;})
    void foo(PutContext context) {
      MemcacheService ms = MemcacheServiceFactory.getMemcacheService();
      // ...
    }

    @PrePut
    void bar(PutContext context) {
      DatastoreService ds = DatastoreServiceFactory.getDatastoreService();
      // ...
    }

    @PostPut(kinds = {&quot;kind1&quot;, &quot;kind2&quot;})
    void baz(PutContext context) {
        Queue q = QueueFactory.getDefaultQueue();
        // ...
    }

    @PostDelete(kinds = {&quot;kind2&quot;})
    void yam(DeleteContext context) {
        URLFetchService us = URLFetchServiceFactory.getURLFetchService();
        // ...
    }
}
</div></section><section class="chapter"><h2 id="common-errors-to-avoid" data-toc="common-errors-to-avoid">Common Errors To Avoid</h2><p id="-w650wr_141">There are a number of common errors to be aware of when implementing callbacks.</p><ul class="list _bullet" id="-w650wr_142"><li class="list__item" id="-w650wr_148"><p id="-w650wr_153"><span id="-w650wr_154">Do Not Maintain Non-static State</span></p></li><li class="list__item" id="-w650wr_149"><p id="-w650wr_155"><span id="-w650wr_156">Do Not Make Assumptions About Callback Execution Order</span></p></li><li class="list__item" id="-w650wr_150"><p id="-w650wr_157"><span id="-w650wr_158">One Callback Per Method</span></p></li><li class="list__item" id="-w650wr_151"><p id="-w650wr_159"><span id="-w650wr_160">Do Not Forget To Retrieve Async Results</span></p></li><li class="list__item" id="-w650wr_152"><p id="-w650wr_161"><span id="-w650wr_162">Avoid Infinite Loops</span></p></li></ul><section class="chapter"><h3 id="do-not-maintain-non-static-state" data-toc="do-not-maintain-non-static-state">Do Not Maintain Non-static State</h3><div class="code-block" data-lang="none">
import java.util.logging.Logger;
import com.google.appengine.api.datastore.PrePut;

class MaintainsNonStaticState {
    static Logger logger = Logger.getLogger(&quot;logger&quot;);
    // ERROR!
    // should be static to avoid assumptions about lifecycle of the instance
    boolean alreadyLogged = false;

    @PrePut
    void log(PutContext context) {
        if (!alreadyLogged) {
            alreadyLogged = true;
            logger.fine(
                &quot;Finished deleting &quot; + context.getCurrentElement().getKey());
        }
    }
}
</div></section><section class="chapter"><h3 id="do-not-make-assumptions-about-callback-execution-order" data-toc="do-not-make-assumptions-about-callback-execution-order">Do Not Make Assumptions About Callback Execution Order</h3><p id="-w650wr_164"><code class="code" id="-w650wr_166">Pre*</code> callbacks will always execute before <code class="code" id="-w650wr_167">Post*</code> callbacks, but it is not safe to make any assumptions about the order in which a <code class="code" id="-w650wr_168">Pre*</code> callback executes relative to other <code class="code" id="-w650wr_169">Pre*</code> callbacks, nor is it safe to make any assumptions about the order in which a <code class="code" id="-w650wr_170">Post*</code> callback executes relative to other <code class="code" id="-w650wr_171">Post*</code> callbacks.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PrePut;

import java.util.HashSet;
import java.util.Set;

class MakesAssumptionsAboutOrderOfCallbackExecution {
    static Set&lt;Key&gt; paymentKeys = new HashSet&lt;Key&gt;();

    @PrePut(kinds = &quot;Order&quot;)
    void prePutOrder(PutContext context) {
        Entity order = context.getCurrentElement();
        paymentKeys.addAll((Collection&lt;Key&gt;) order.getProperty(&quot;payment_keys&quot;));
    }

    @PrePut(kinds = &quot;Payment&quot;)
    void prePutPayment(PutContext context) {
        // ERROR!
        // Not safe to assume prePutOrder() has already run!
        if (!paymentKeys.contains(context.getCurrentElement().getKey()) {
            throw new IllegalArgumentException(&quot;Unattached payment!&quot;);
        }
    }
}
</div></section><section class="chapter"><h3 id="one-callback-per-method" data-toc="one-callback-per-method">One Callback Per Method</h3><p id="-w650wr_172">Even though a class can have an unlimited number of callback methods, a single method can only be associated with a single callback.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PostPut;

class MultipleCallbacksOnAMethod {
    @PrePut
    @PostPut // Compiler error!
    void foo(PutContext context) { }
}
</div></section><section class="chapter"><h3 id="do-not-forget-to-retrieve-async-results" data-toc="do-not-forget-to-retrieve-async-results">Do Not Forget To Retrieve Async Results</h3><p id="-w650wr_174"><code class="code" id="-w650wr_176">Post*</code> callbacks do not run until you call <a href="https://web.archive.org/web/20160424230753/http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html#get()" id="-w650wr_177" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-w650wr_180">Future.get()</code></a> to retrieve the result of the operation. If you forget to call <code class="code" id="-w650wr_178">Future.get()</code> before you finish servicing the HTTP request, your <code class="code" id="-w650wr_179">Post*</code> callbacks will not run.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.AsyncDatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PostPut;
import com.google.appengine.api.datastore.PutContext;

import java.util.concurrent.Future;

class IgnoresAsyncResult {
    AsyncDatastoreService ds = DatastoreServiceFactory.getAsyncDatastoreService();

    @PostPut
    void collectSample(PutContext context) {
        Sampler.getSampler().collectSample(
            &quot;put&quot;, context.getCurrentElement().getKey());
    }

    void addOrder(Entity order) {
        Future result = ds.put(order);
        // ERROR! Never calls result.get() so collectSample() will not run.
    }
}
</div></section><section class="chapter"><h3 id="avoid-infinite-loops" data-toc="avoid-infinite-loops">Avoid Infinite Loops</h3><p id="-w650wr_181">If you perform datastore operations in your callbacks, be careful not to fall into an infinite loop.</p><div class="code-block" data-lang="none">
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PrePut;
import com.google.appengine.api.datastore.PutContext;

class InfiniteLoop {
    DatastoreService ds = DatastoreServiceFactory.getDatastoreService();

    @PrePut
    void audit(PutContext context) {
        Entity original = ds.get(context.getCurrentElement().getKey());
        Entity auditEntity = new Entity(original.getKind() + &quot;_audit&quot;);
        auditEntity.setPropertiesFrom(original);
        // INFINITE LOOP!
        // Restricting the callback to specific kinds would solve this.
        ds.put(auditEntity);
    }
}
</div></section></section><section class="chapter"><h2 id="using-callbacks-with-eclipse" data-toc="using-callbacks-with-eclipse">Using Callbacks With Eclipse</h2><p id="-w650wr_183">If you are developing your app with Eclipse you will need to perform a small number of configuration steps to use datastore callbacks. These steps are for Eclipse 3.7. We expect to make these steps unnecessary in a future release of the Google Plugin For Eclipse.</p><ul class="list _bullet" id="-w650wr_184"><li class="list__item" id="-w650wr_186"><p id="-w650wr_194">Open the Properties dialog for your Project (Project &gt; Properties)</p></li><li class="list__item" id="-w650wr_187"><p id="-w650wr_195">Open the Annotation Processing dialog (Java Compiler &gt; Annotation Processing)</p></li><li class="list__item" id="-w650wr_188"><p id="-w650wr_196">Check &quot;Enable annotation processing&quot;</p></li><li class="list__item" id="-w650wr_189"><p id="-w650wr_197">Check &quot;Enable processing in editor&quot;</p></li><li class="list__item" id="-w650wr_190"><p id="-w650wr_198">Open the Factory Path dialog (Java Compiler &gt; Annotation Processing &gt; Factory Path)</p></li><li class="list__item" id="-w650wr_191"><p id="-w650wr_199">Click &quot;Add External JARs&quot;</p></li><li class="list__item" id="-w650wr_192"><p id="-w650wr_200">Select &lt;SDK_ROOT&gt;/lib/impl/appengine-api.jar (where SDK_ROOT is the top level directory of your sdk installation)</p></li><li class="list__item" id="-w650wr_193"><p id="-w650wr_201">Click &quot;OK&quot;</p></li></ul><p id="-w650wr_185">You can verify that callbacks are properly configured by implementing a method with multiple callbacks (see the code snippet under <span id="-w650wr_202">One Callback Per Method</span>). This should generate a compiler error.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="async-datastore-api.html" class="navigation-links__prev">Async Datastore API</a><a href="managing-datastore-from-the-google-cloud-platform-console.html" class="navigation-links__next">Managing Datastore from the Google Cloud Platform Console</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>