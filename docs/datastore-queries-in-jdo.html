<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:45.517212293"><title>Datastore Queries in JDO | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"contents","level":0,"title":"Contents","anchor":"#contents"},{"id":"queries-with-jdoql","level":0,"title":"Queries with JDOQL","anchor":"#queries-with-jdoql"},{"id":"key-based-queries","level":0,"title":"Key-Based Queries","anchor":"#key-based-queries"},{"id":"extents","level":0,"title":"Extents","anchor":"#extents"},{"id":"deleting-entities-by-query","level":0,"title":"Deleting Entities by Query","anchor":"#deleting-entities-by-query"},{"id":"query-cursors","level":0,"title":"Query Cursors","anchor":"#query-cursors"},{"id":"datastore-read-policy-and-call-deadline","level":0,"title":"Datastore Read Policy and Call Deadline","anchor":"#datastore-read-policy-and-call-deadline"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Datastore Queries in JDO | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/datastore-queries-in-jdo.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Datastore Queries in JDO | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/datastore-queries-in-jdo.html#webpage",
    "url": "writerside-documentation/datastore-queries-in-jdo.html",
    "name": "Datastore Queries in JDO | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Datastore-Queries-in-JDO" data-main-title="Datastore Queries in JDO" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Superseded-Storage-Solutions.md|Superseded Storage Solutions///JDO-for-Cloud-Datastore.md|JDO for Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Datastore-Queries-in-JDO" id="Datastore-Queries-in-JDO.md">Datastore Queries in JDO</h1><p id="o87fab_3">This document focuses on the use of the <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/index" id="o87fab_18" data-external="true" rel="noopener noreferrer" target="_blank">Java Data Objects (JDO)</a> persistence framework for App Engine Datastore queries. For more general information about queries, see the main <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/queries" id="o87fab_19" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page.</p><p id="o87fab_4">A Datastore <span class="emphasis" id="o87fab_20">query</span> retrieves <span class="emphasis" id="o87fab_21"><a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/entities" id="o87fab_28" data-external="true" rel="noopener noreferrer" target="_blank">entities</a></span> from the App Engine Datastore that meet a specified set of conditions. The query operates on entities of a given <span class="emphasis" id="o87fab_22"><a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="o87fab_29" data-external="true" rel="noopener noreferrer" target="_blank">kind</a></span>; it can specify <span class="emphasis" id="o87fab_23"><span id="o87fab_30">filters</span></span> on the entities' property values, keys, and ancestors, and can return zero or more entities as <span class="emphasis" id="o87fab_24">results.</span> A query can also specify <span class="emphasis" id="o87fab_25"><span id="o87fab_31">sort orders</span></span> to sequence the results by their property values. The results include all entities that have at least one (possibly null) value for every property named in the filters and sort orders, and whose property values meet all the specified filter criteria. The query can return entire entities, <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/projectionqueries" id="o87fab_26" data-external="true" rel="noopener noreferrer" target="_blank">projected entities</a>, or just entity <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/#Java_Kinds_keys_and_identifiers" id="o87fab_27" data-external="true" rel="noopener noreferrer" target="_blank">keys</a>.</p><p id="o87fab_5">A typical query includes the following:</p><ul class="list _bullet" id="o87fab_6"><li class="list__item" id="o87fab_32"><p id="o87fab_35">An <span class="emphasis" id="o87fab_36"><a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="o87fab_37" data-external="true" rel="noopener noreferrer" target="_blank">entity kind</a></span> to which the query applies</p></li><li class="list__item" id="o87fab_33"><p id="o87fab_38">Zero or more <span class="emphasis" id="o87fab_39"><span id="o87fab_40">filters</span></span> based on the entities' property values, keys, and ancestors</p></li><li class="list__item" id="o87fab_34"><p id="o87fab_41">Zero or more <span class="emphasis" id="o87fab_42"><span id="o87fab_43">sort orders</span></span> to sequence the results</p></li></ul><p id="o87fab_7">When executed, the query retrieves all entities of the given kind that satisfy all of the given filters, sorted in the specified order. Queries execute as read-only.</p><p id="o87fab_8"><span class="control" id="o87fab_44">Note:</span> To conserve memory and improve performance, a query should, whenever possible, specify a limit on the number of results returned.</p><p id="o87fab_9">Every Datastore query computes its results using one or more <span class="emphasis" id="o87fab_45"><a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/indexes" id="o87fab_46" data-external="true" rel="noopener noreferrer" target="_blank">indexes</a>,</span> which contain entity keys in a sequence specified by the index's properties and, optionally, the entity's ancestors. The indexes are updated incrementally to reflect any changes the application makes to its entities, so that the correct results of all queries are available with no further computation needed.</p><p id="o87fab_10"><span class="control" id="o87fab_47">Note:</span> The index-based query mechanism supports a wide range of queries and is suitable for most applications. However, it does not support some kinds of query common in other database technologies: in particular, joins and aggregate queries aren't supported within the Datastore query engine. See the <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Restrictions_on_queries" id="o87fab_48" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page for limitations on Datastore queries.</p><section class="chapter"><h2 id="contents" data-toc="contents">Contents</h2><ol class="list _decimal" id="o87fab_49" type="1"><li class="list__item" id="o87fab_50"><p id="o87fab_56"><span id="o87fab_58">Queries with JDOQL</span></p><ol class="list _decimal" id="o87fab_57" type="1"><li class="list__item" id="o87fab_59"><p id="o87fab_62"><span id="o87fab_63">Filters</span></p></li><li class="list__item" id="o87fab_60"><p id="o87fab_64"><span id="o87fab_65">Sort Orders</span></p></li><li class="list__item" id="o87fab_61"><p id="o87fab_66"><span id="o87fab_67">Ranges</span></p></li></ol></li><li class="list__item" id="o87fab_51"><p id="o87fab_68"><span id="o87fab_69">Key-Based Queries</span></p></li><li class="list__item" id="o87fab_52"><p id="o87fab_70"><span id="o87fab_71">Extents</span></p></li><li class="list__item" id="o87fab_53"><p id="o87fab_72"><span id="o87fab_73">Deleting Entities by Query</span></p></li><li class="list__item" id="o87fab_54"><p id="o87fab_74"><span id="o87fab_75">Query Cursors</span></p></li><li class="list__item" id="o87fab_55"><p id="o87fab_76"><span id="o87fab_77">Datastore Read Policy and Call Deadline</span></p></li></ol></section><section class="chapter"><h2 id="queries-with-jdoql" data-toc="queries-with-jdoql">Queries with JDOQL</h2><p id="o87fab_78">JDO includes a query language for retrieving objects that meet a set of criteria. This language, called <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/jdoql" id="o87fab_91" data-external="true" rel="noopener noreferrer" target="_blank">JDOQL</a>, refers to JDO data classes and fields directly, and includes type checking for query parameters and results. JDOQL is similar to SQL, but is more appropriate for object-oriented databases like the App Engine Datastore. (App Engine's implementation of the JDO API doesn't support SQL queries directly.)</p><p id="o87fab_79">The JDO <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query" id="o87fab_92" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_96">Query</code></a> interface supports several calling styles: you can specify a complete query in a string, using the JDOQL string syntax, or you can specify some or all parts of the query by calling methods on the <code class="code" id="o87fab_93">Query</code> object. The following example shows the method style of calling, with one filter and one sort order, using parameter substitution for the value used in the filter. The argument values passed to the <code class="code" id="o87fab_94">Query</code> object's <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#execute()" id="o87fab_95" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_97">execute()</code></a> method are substituted into the query in the order specified:</p><div class="code-block" data-lang="none">
import java.util.List;
import javax.jdo.Query;

// ...

Query q = pm.newQuery(Person.class);
q.setFilter(&quot;lastName == lastNameParam&quot;);
q.setOrdering(&quot;height desc&quot;);
q.declareParameters(&quot;String lastNameParam&quot;);

try {
  List&lt;Person&gt; results = (List&lt;Person&gt;) q.execute(&quot;Smith&quot;);
  if (!results.isEmpty()) {
    for (Person p : results) {
      // Process result p
    }
  } else {
    // Handle &quot;no results&quot; case
  }
} finally {
  q.closeAll();
}
</div><p id="o87fab_81">Here is the same query using the string syntax:</p><div class="code-block" data-lang="none">
Query q = pm.newQuery(&quot;select from Person &quot; +
                      &quot;where lastName == lastNameParam &quot; +
                      &quot;parameters String lastNameParam &quot; +
                      &quot;order by height desc&quot;);

List&lt;Person&gt; results = (List&lt;Person&gt;) q.execute(&quot;Smith&quot;);
</div><p id="o87fab_83">You can mix these styles of defining the query. For example:</p><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class,
                      &quot;lastName == lastNameParam order by height desc&quot;);
q.declareParameters(&quot;String lastNameParam&quot;);

List&lt;Person&gt; results = (List&lt;Person&gt;) q.execute(&quot;Smith&quot;);
</div><p id="o87fab_85">You can reuse a single <code class="code" id="o87fab_98">Query</code> instance with different values substituted for the parameters by calling the <code class="code" id="o87fab_99">execute()</code> method multiple times. Each call performs the query and returns the results as a collection.</p><p id="o87fab_86">The JDOQL string syntax supports literal specification of string and numeric values; all other value types must use parameter substitution. Literals within the query string can be enclosed in either single (<code class="code" id="o87fab_100">'</code>) or double (<code class="code" id="o87fab_101">&quot;</code>) quotation marks. Here is an example using a string literal:</p><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class,
                      &quot;lastName == 'Smith' order by height desc&quot;);
</div><section class="chapter"><h3 id="filters" data-toc="filters">Filters</h3><p id="o87fab_102">A <span class="emphasis" id="o87fab_120">property filter</span> specifies</p><ul class="list _bullet" id="o87fab_103"><li class="list__item" id="o87fab_121"><p id="o87fab_124">A property name</p></li><li class="list__item" id="o87fab_122"><p id="o87fab_125">A comparison operator</p></li><li class="list__item" id="o87fab_123"><p id="o87fab_126">A property value</p></li></ul><p id="o87fab_104">For example:</p><div class="code-block" data-lang="none">
Filter propertyFilter =
  new FilterPredicate(&quot;height&quot;,
                      FilterOperator.GREATER_THAN_OR_EQUAL,
                      minHeight);
Query q = new Query(&quot;Person&quot;).setFilter(propertyFilter);
</div><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class);
q.setFilter(&quot;height &lt;= maxHeight&quot;);
</div><p id="o87fab_107">The property value must be supplied by the application; it cannot refer to or be calculated in terms of other properties. An entity satisfies the filter if it has a property of the given name whose value compares to the value specified in the filter in the manner described by the comparison operator.</p><p id="o87fab_108">The comparison operator can be any of the following:</p><div class="table-wrapper"><table class="wide" id="o87fab_109"><thead><tr class="ijRowHead" id="o87fab_127"><th id="o87fab_134"><p>Operator</p></th><th id="o87fab_135"><p>Meaning</p></th></tr></thead><tbody><tr id="o87fab_128"><td id="o87fab_136"><p><code class="code" id="o87fab_138">==</code></p></td><td id="o87fab_137"><p>Equal to</p></td></tr><tr id="o87fab_129"><td id="o87fab_139"><p><code class="code" id="o87fab_141">&lt;</code></p></td><td id="o87fab_140"><p>Less than</p></td></tr><tr id="o87fab_130"><td id="o87fab_142"><p><code class="code" id="o87fab_144">&lt;=</code></p></td><td id="o87fab_143"><p>Less than or equal to</p></td></tr><tr id="o87fab_131"><td id="o87fab_145"><p><code class="code" id="o87fab_147">&gt;</code></p></td><td id="o87fab_146"><p>Greater than</p></td></tr><tr id="o87fab_132"><td id="o87fab_148"><p><code class="code" id="o87fab_150">&gt;=</code></p></td><td id="o87fab_149"><p>Greater than or equal to</p></td></tr><tr id="o87fab_133"><td id="o87fab_151"><p><code class="code" id="o87fab_153">!=</code></p></td><td id="o87fab_152"><p>Not equal to</p></td></tr></tbody></table></div><p id="o87fab_110">As described on the main <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/queries#Restrictions_on_Queries" id="o87fab_154" data-external="true" rel="noopener noreferrer" target="_blank">Queries</a> page, a single query cannot use inequality filters (<code class="code" id="o87fab_155">&lt;</code>, <code class="code" id="o87fab_156">&lt;=</code>, <code class="code" id="o87fab_157">&gt;</code>, <code class="code" id="o87fab_158">&gt;=</code>, <code class="code" id="o87fab_159">!=</code>) on more than one property. (Multiple inequality filters on the same property, such as querying for a range of values, are permitted.) <code class="code" id="o87fab_160">contains()</code> filters, corresponding to <code class="code" id="o87fab_161">IN</code> filters in SQL, are supported using the following syntax:</p><div class="code-block" data-lang="none">
// Query for all persons with lastName equal to Smith or Jones
Query q = pm.newQuery(Person.class, &quot;:p.contains(lastName)&quot;);
q.execute(Arrays.asList(&quot;Smith&quot;, &quot;Jones&quot;));
</div><p id="o87fab_112">The not-equal (<code class="code" id="o87fab_162">!=</code>) operator actually performs two queries: one in which all other filters are unchanged and the not-equal filter is replaced with a less-than (<code class="code" id="o87fab_163">&lt;</code>) filter, and one where it is replaced with a greater-than (<code class="code" id="o87fab_164">&gt;</code>) filter. The results are then merged, in order. A query can have no more than one not-equal filter, and a query that has one cannot have any other inequality filters.</p><p id="o87fab_113">The <code class="code" id="o87fab_165">contains()</code> operator also performs multiple queries: one for each item in the specified list, with all other filters unchanged and the <code class="code" id="o87fab_166">contains()</code> filter replaced with an equality (<code class="code" id="o87fab_167">==</code>) filter. The results are merged in order of the items in the list. If a query has more than one <code class="code" id="o87fab_168">contains()</code> filter, it is performed as multiple queries, one for each possible <span class="emphasis" id="o87fab_169">combination</span> of values in the <code class="code" id="o87fab_170">contains()</code> lists.</p><p id="o87fab_114">A single query containing not-equal (<code class="code" id="o87fab_171">!=</code>) or <code class="code" id="o87fab_172">contains()</code> operators is limited to no more than 30 subqueries.</p><p id="o87fab_115">For more information about how <code class="code" id="o87fab_173">!=</code> and <code class="code" id="o87fab_174">contains()</code> queries translate to multiple queries in a JDO/JPA framework, see the article <a href="https://web.archive.org/web/20160424230825/http://gae-java-persistence.blogspot.com/2009/12/queries-with-and-in-filters.html" id="o87fab_175" data-external="true" rel="noopener noreferrer" target="_blank">Queries with != and IN filters</a>.</p><p id="o87fab_116">In the JDOQL string syntax, you can separate multiple filters with the <code class="code" id="o87fab_176">&amp;&amp;</code> (logical &quot;and&quot;) and <code class="code" id="o87fab_177">||</code> (logical &quot;or&quot;) operators:</p><div class="code-block" data-lang="none">
q.setFilter(&quot;lastName == 'Smith' &amp;&amp; height &lt; maxHeight&quot;);
</div><p id="o87fab_118">Negation (logical &quot;not&quot;) is not supported. Keep in mind, also, that the <code class="code" id="o87fab_178">||</code> operator can be employed only when the filters it separates all have the same property name (that is, when they can be combined into a single <code class="code" id="o87fab_179">contains()</code> filter):</p><div class="code-block" data-lang="none">
// Legal: all filters separated by || are on the same property
Query q = pm.newQuery(Person.class,
                      &quot;(lastName == 'Smith' || lastName == 'Jones')&quot; +
                      &quot; &amp;&amp; firstName == 'Harold'&quot;);

// Not legal: filters separated by || are on different properties
Query q = pm.newQuery(Person.class,
                      &quot;lastName == 'Smith' || firstName == 'Harold'&quot;);
</div></section><section class="chapter"><h3 id="sort-orders" data-toc="sort-orders">Sort Orders</h3><p id="o87fab_180">A query <span class="emphasis" id="o87fab_191">sort order</span> specifies</p><ul class="list _bullet" id="o87fab_181"><li class="list__item" id="o87fab_192"><p id="o87fab_194">A property name</p></li><li class="list__item" id="o87fab_193"><p id="o87fab_195">A sort direction (ascending or descending)</p></li></ul><p id="o87fab_182">For example:</p><div class="code-block" data-lang="none">
// Order alphabetically by last name:
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING);

// Order by height, tallest to shortest:
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;height&quot;, SortDirection.DESCENDING);
</div><p id="o87fab_184">For example:</p><div class="code-block" data-lang="none">
// Order alphabetically by last name:
Query q = pm.newQuery(Person.class);
q.setOrdering(&quot;lastName asc&quot;);

// Order by height, tallest to shortest:
Query q = pm.newQuery(Person.class);
q.setOrdering(&quot;height desc&quot;);
</div><p id="o87fab_186">If a query includes multiple sort orders, they are applied in the sequence specified. The following example sorts first by ascending last name and then by descending height:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .addSort(&quot;lastName&quot;, SortDirection.ASCENDING)
                .addSort(&quot;height&quot;, SortDirection.DESCENDING);
</div><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class);
q.setOrdering(&quot;lastName asc, height desc&quot;);
</div><p id="o87fab_189">If no sort orders are specified, the results are returned in the order they are retrieved from the Datastore.</p><p id="o87fab_190"><span class="control" id="o87fab_196">Note:</span> Because of the way the App Engine Datastore executes queries, if a query specifies inequality filters on a property and sort orders on other properties, the property used in the inequality filters must be ordered before the other properties.</p></section><section class="chapter"><h3 id="ranges" data-toc="ranges">Ranges</h3><p id="o87fab_197">A query can specify a <span class="emphasis" id="o87fab_200">range</span> of results to be returned to the application. The range indicates which results in the complete result set should be the first and last returned. Results are identified by their numeric indices, with <code class="code" id="o87fab_201">0</code> denoting the first result in the set. For example, a range of <code class="code" id="o87fab_202">5,</code> <code class="code" id="o87fab_203">10</code> returns the 6th through 10th results:</p><div class="code-block" data-lang="none">
q.setRange(5, 10);
</div><p id="o87fab_199"><span class="control" id="o87fab_204">Note:</span> The use of ranges can affect performance, since the Datastore must retrieve and then discard all results preceding the starting offset. For example, a query with a range of <code class="code" id="o87fab_205">5,</code> <code class="code" id="o87fab_206">10</code> retrieves ten results from the Datastore, discards the first five, and returns the remaining five to the application.</p></section></section><section class="chapter"><h2 id="key-based-queries" data-toc="key-based-queries">Key-Based Queries</h2><p id="o87fab_207">Entity keys can be the subject of a query filter or sort order. The Datastore considers the complete key value for such queries, including the entity's ancestor path, the kind, and the application-assigned key name string or system-assigned numeric ID. Because the key is unique across all entities in the system, key queries make it easy to retrieve entities of a given kind in batches, such as for a batch dump of the contents of the Datastore. Unlike JDOQL ranges, this works efficiently for any number of entities.</p><p id="o87fab_208">When comparing for inequality, keys are ordered by the following criteria, in order:</p><ol class="list _decimal" id="o87fab_209" type="1"><li class="list__item" id="o87fab_217"><p id="o87fab_220">Ancestor path</p></li><li class="list__item" id="o87fab_218"><p id="o87fab_221">Entity kind</p></li><li class="list__item" id="o87fab_219"><p id="o87fab_222">Identifier (key name or numeric ID)</p></li></ol><p id="o87fab_210">Elements of the ancestor path are compared similarly: by kind (string), then by key name or numeric ID. Kinds and key names are strings and are ordered by byte value; numeric IDs are integers and are ordered numerically. If entities with the same parent and kind use a mix of key name strings and numeric IDs, those with numeric IDs precede those with key names.</p><p id="o87fab_211">In JDO, you refer to the entity key in the query using the primary key field of the object. To use a key as a query filter, you specify the parameter type <code class="code" id="o87fab_223">Key</code> to the <code class="code" id="o87fab_224"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#declareParameters(java.lang.String)" id="o87fab_225" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_230">declareParameters()</code></a> method. The following finds all <code class="code" id="o87fab_226">Person</code> entities with a given favorite food, assuming an <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/jdo/relationships#Unowned_Relationships" id="o87fab_227" data-external="true" rel="noopener noreferrer" target="_blank">unowned one-to-one relationship</a> between <code class="code" id="o87fab_228">Person</code> and <code class="code" id="o87fab_229">Food</code>:</p><div class="code-block" data-lang="none">
Food chocolate = /*...*/;

Query q = pm.newQuery(Person.class);
q.setFilter(&quot;favoriteFood == favoriteFoodParam&quot;);
q.declareParameters(Key.class.getName() + &quot; favoriteFoodParam&quot;);

List&lt;Person&gt; chocolateLovers = (List&lt;Person&gt;) q.execute(chocolate.getKey());
</div><p id="o87fab_213">A <span class="emphasis" id="o87fab_231">keys-only query</span> returns just the keys of the result entities instead of the entities themselves, at lower latency and cost than retrieving entire entities:</p><div class="code-block" data-lang="none">
Query q = new Query(&quot;Person&quot;)
                .setKeysOnly();
</div><div class="code-block" data-lang="none">
Query q = pm.newQuery(&quot;select id from &quot; + Person.class.getName());
List&lt;String&gt; ids = (List&lt;String&gt;) q.execute();
</div><p id="o87fab_216">It is often more economical to do a keys-only query first, and then fetch a subset of entities from the results, rather than executing a general query which may fetch more entities than you actually need.</p></section><section class="chapter"><h2 id="extents" data-toc="extents">Extents</h2><p id="o87fab_232">A JDO <span class="emphasis" id="o87fab_235">extent</span> represents every object in the Datastore of a particular class. You create it by passing the desired class to the Persistence Manager's <code class="code" id="o87fab_236"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/PersistenceManager#getExtent(java.lang.Class)" id="o87fab_237" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_242">getExtent()</code></a> method. The <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Extent" id="o87fab_238" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_243">Extent</code></a> interface extends the <code class="code" id="o87fab_239"></code><a href="//web.archive.org/web/20160424230825/https://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html" id="o87fab_240" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_244">Iterable</code></a> interface for accessing results, retrieving them in batches as needed. When you're finished accessing the results, you call the extent's <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Extent#closeAll()" id="o87fab_241" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_245">closeAll()</code></a> method.</p><p id="o87fab_233">The following example iterates over every <code class="code" id="o87fab_246">Person</code> object in the Datastore:</p><div class="code-block" data-lang="none">
import java.util.Iterator;
import javax.jdo.Extent;

// ...

Extent&lt;Person&gt; extent = pm.getExtent(Person.class, false);
for (Person p : extent) {
  // ...
}
extent.closeAll();
</div></section><section class="chapter"><h2 id="deleting-entities-by-query" data-toc="deleting-entities-by-query">Deleting Entities by Query</h2><p id="o87fab_247">If you are issuing a query with the goal of deleting all the entities that match the query filter, you can save yourself a bit of coding by using JDO's &quot;delete by query&quot; feature. The following deletes all persons over a given height:</p><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class);
q.setFilter(&quot;height &gt; maxHeightParam&quot;);
q.declareParameters(&quot;int maxHeightParam&quot;);
q.deletePersistentAll(maxHeight);
</div><p id="o87fab_249">You'll notice that the only difference here is that we are calling <code class="code" id="o87fab_250"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#deletePersistentAll()" id="o87fab_251" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_257">q.deletePersistentAll()</code></a> instead of <a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#execute()" id="o87fab_252" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_258">q.execute()</code></a>. All of the rules and restrictions described above for filters, sort orders, and indexes apply to queries whether you are selecting or deleting the result set. Note, however, that just as if you had deleted these <code class="code" id="o87fab_253">Person</code> entities with <code class="code" id="o87fab_254"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/PersistenceManager#deletePersistent(java.lang.Object)" id="o87fab_255" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_259">pm.deletePersistent()</code></a>, any dependent children of the entities deleted by the query will also be deleted. For more information on dependent children, see the <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/jdo/relationships#Dependent_Children_and_Cascading_Deletes" id="o87fab_256" data-external="true" rel="noopener noreferrer" target="_blank">Entity Relationships in JDO</a> page.</p></section><section class="chapter"><h2 id="query-cursors" data-toc="query-cursors">Query Cursors</h2><p id="o87fab_260">In JDO, you can use an extension and the <code class="code" id="o87fab_263">JDOCursorHelper</code> class to use cursors with JDO queries. Cursors work when fetching results as a list or using an iterator. To get a cursor, you pass either the result list or iterator to the static method <code class="code" id="o87fab_264">JDOCursorHelper.getCursor()</code>:</p><div class="code-block" data-lang="none">
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.jdo.Query;
import com.google.appengine.api.datastore.Cursor;
import org.datanucleus.store.appengine.query.JDOCursorHelper;


Query q = pm.newQuery(Person.class);
q.setRange(0, 20);

List&lt;Person&gt; results = (List&lt;Person&gt;) q.execute();
// Use the first 20 results

Cursor cursor = JDOCursorHelper.getCursor(results);
String cursorString = cursor.toWebSafeString();
// Store the cursorString

// ...

// Query q = the same query that produced the cursor
// String cursorString = the string from storage
Cursor cursor = Cursor.fromWebSafeString(cursorString);
Map&lt;String, Object&gt; extensionMap = new HashMap&lt;String, Object&gt;();
extensionMap.put(JDOCursorHelper.CURSOR_EXTENSION, cursor);
q.setExtensions(extensionMap);
q.setRange(0, 20);

List&lt;Person&gt; results = (List&lt;Person&gt;) q.execute();
// Use the next 20 results
</div><p id="o87fab_262">For more information on query cursors, see the <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/queries#Query_Cursors" id="o87fab_265" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page.</p></section><section class="chapter"><h2 id="datastore-read-policy-and-call-deadline" data-toc="datastore-read-policy-and-call-deadline">Datastore Read Policy and Call Deadline</h2><p id="o87fab_266">You can set the read policy (strong consistency vs. eventual consistency) and the Datastore call deadline for all calls made by a <code class="code" id="o87fab_274">PersistenceManager</code> instance using configuration. You can also override these options for an individual <code class="code" id="o87fab_275">Query</code> object. (Note, however, that there is no way to override the configuration for these options when you fetch entities by key.)</p><p id="o87fab_267">When eventual consistency is selected for a Datastore query, the indexes the query uses to gather results are also accessed with eventual consistency. Queries occasionally return entities that don't match the query criteria&mdash;though this is also true with a strongly consistent read policy. (If the query uses an ancestor filter, you can use <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/docs/java/datastore/transactions" id="o87fab_276" data-external="true" rel="noopener noreferrer" target="_blank">transactions</a> to ensure a consistent result set.) See the article <a href="https://web.archive.org/web/20160424230825/https://cloud.google.com/appengine/articles/transaction_isolation" id="o87fab_277" data-external="true" rel="noopener noreferrer" target="_blank">Transaction Isolation in App Engine</a> for more information on how entities and indexes are updated.</p><p id="o87fab_268">To override the read policy for a single query, call its <code class="code" id="o87fab_278"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#addExtension(java.lang.String,%20java.lang.Object)" id="o87fab_279" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_280">addExtension()</code></a> method:</p><div class="code-block" data-lang="none">
Query q = pm.newQuery(Person.class);
q.addExtension(&quot;datanucleus.appengine.datastoreReadConsistency&quot;, &quot;EVENTUAL&quot;);
</div><p id="o87fab_270">The possible values are <code class="code" id="o87fab_281">&quot;EVENTUAL&quot;</code> and <code class="code" id="o87fab_282">&quot;STRONG&quot;</code>; the default is <code class="code" id="o87fab_283">&quot;STRONG&quot;</code>, unless set otherwise in the configuration file <code class="code" id="o87fab_284">jdoconfig.xml</code>.</p><p id="o87fab_271">To override the Datastore call deadline for a single query, call its <code class="code" id="o87fab_285"></code><a href="https://web.archive.org/web/20160424230825/http://db.apache.org/jdo/api30/apidocs/javax/jdo/Query#setDatastoreReadTimeoutMillis(java.lang.Integer)" id="o87fab_286" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="o87fab_287">setDatastoreReadTimeoutMillis()</code></a> method:</p><div class="code-block" data-lang="none">
q.setDatastoreReadTimeoutMillis(3000);
</div><p id="o87fab_273">The value is a time interval expressed in milliseconds.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="entity-relationships-in-jdo.html" class="navigation-links__prev">Entity Relationships in JDO</a><a href="jpa-for-cloud-datastore.html" class="navigation-links__next">JPA for Cloud Datastore</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>