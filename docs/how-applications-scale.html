<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:48.268747287"><title>How Applications Scale | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"introduction-to-instances","level":0,"title":"Introduction to Instances","anchor":"#introduction-to-instances"},{"id":"scaling-dynamic-instances","level":0,"title":"Scaling dynamic instances","anchor":"#scaling-dynamic-instances"},{"id":"request-throughput-and-latency","level":0,"title":"Request throughput and latency","anchor":"#request-throughput-and-latency"},{"id":"special-kinds-of-requests","level":0,"title":"Special kinds of requests","anchor":"#special-kinds-of-requests"},{"id":"instance-billing","level":0,"title":"Instance billing","anchor":"#instance-billing"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="How Applications Scale | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/how-applications-scale.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="How Applications Scale | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/how-applications-scale.html#webpage",
    "url": "writerside-documentation/how-applications-scale.html",
    "name": "How Applications Scale | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="How-Applications-Scale" data-main-title="How Applications Scale" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts.md|Concepts"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="How-Applications-Scale" id="How-Applications-Scale.md">How Applications Scale</h1><p id="zflui8_3"><a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/python/scaling" id="zflui8_12" data-tooltip="View this page in the Python runtime" data-external="true" rel="noopener noreferrer" target="_blank">Python</a> |Java |<a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/php/scaling" id="zflui8_13" data-tooltip="View this page in the PHP runtime" data-external="true" rel="noopener noreferrer" target="_blank">PHP</a> |<a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/go/scaling" id="zflui8_14" data-tooltip="View this page in the Go runtime" data-external="true" rel="noopener noreferrer" target="_blank">Go</a></p><p id="zflui8_4">Instances are the basic building blocks of App Engine, providing all the resources needed to successfully host your application. This includes the language runtime, the App Engine APIs, and your application's code and memory. Each instance includes a security layer to ensure that instances cannot inadvertently affect each other.</p><p id="zflui8_5">Instances are the computing units that App Engine uses to automatically scale your application. At any given time, your application may be running on one instance or many instances, with requests being spread across all of them.</p><ol class="list _decimal" id="zflui8_6" type="1"><li class="list__item" id="zflui8_15"><p id="zflui8_20"><span id="zflui8_21">Introduction to Instances</span></p></li><li class="list__item" id="zflui8_16"><p id="zflui8_22"><span id="zflui8_23">Scaling dynamic instances</span></p></li><li class="list__item" id="zflui8_17"><p id="zflui8_24"><span id="zflui8_25">Request throughput and latency</span></p></li><li class="list__item" id="zflui8_18"><p id="zflui8_26"><span id="zflui8_28">Special kinds of requests</span></p><ol class="list _decimal" id="zflui8_27" type="1"><li class="list__item" id="zflui8_29"><p id="zflui8_31"><span id="zflui8_32">Loading requests</span></p></li><li class="list__item" id="zflui8_30"><p id="zflui8_33"><span id="zflui8_34">Warmup requests</span></p></li></ol></li><li class="list__item" id="zflui8_19"><p id="zflui8_35"><span id="zflui8_36">Instance billing</span></p></li></ol><section class="chapter"><h2 id="introduction-to-instances" data-toc="introduction-to-instances">Introduction to Instances</h2><p id="zflui8_37">Instances are <span class="emphasis" id="zflui8_44">resident</span> or <span class="emphasis" id="zflui8_45">dynamic</span>. A dynamic instance starts up and shuts down automatically based on the current needs. A resident instance runs all the time, which can improve your application's performance.</p><p id="zflui8_38">An instance instantiates the code which is included in an App Engine <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/features/#modules" id="zflui8_46" data-external="true" rel="noopener noreferrer" target="_blank">module</a>.</p><p id="zflui8_39">When you configure your app, you specify how its modules scale (the initial number of instances for a module and how new instances are created and stopped in response to traffic), and how much time an instance is allowed to handle a request (its deadline).</p><p id="zflui8_40">The scaling class that you assign to a module determines the kind(s) of instances created:</p><ul class="list _bullet" id="zflui8_41"><li class="list__item" id="zflui8_47"><p id="zflui8_50">Manual scaling modules use resident instances</p></li><li class="list__item" id="zflui8_48"><p id="zflui8_51">Basic scaling modules use dynamic instances</p></li><li class="list__item" id="zflui8_49"><p id="zflui8_52">Auto scaling modules use dynamic instances - but if you specify a number, N, of minimum idle instances, the first N instances will be resident, and additional dynamic instances will be created as necessary.</p></li></ul><p id="zflui8_42">App Engine charges for instance usage on an hourly basis. You can track your instance usage on the Google Cloud Platform Console <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/developers-console/#instances" id="zflui8_53" data-external="true" rel="noopener noreferrer" target="_blank">Instances page</a>. If you want to set a limit on incurred instance costs, you can do so by <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/java/console#billing" id="zflui8_54" data-external="true" rel="noopener noreferrer" target="_blank">setting a spending limit</a>.</p><p id="zflui8_43">When App Engine was first released, the modules architecture did not exist. Applications were constructed with one frontend and multiple, optional <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/python/backends" id="zflui8_55" data-external="true" rel="noopener noreferrer" target="_blank">backends</a>. A frontend behaves like an auto scaling version of the default module. A backend can behave as either a manual or basic scaling module, depending on how it's configured. <span class="control" id="zflui8_56">Note that backends have been deprecated</span>.</p></section><section class="chapter"><h2 id="scaling-dynamic-instances" data-toc="scaling-dynamic-instances">Scaling dynamic instances</h2><p id="zflui8_57">App Engine applications are powered by any number of dynamic instances at a given time, depending on the volume of incoming requests. As requests for your application increase, so do the number of dynamic instances.</p><p id="zflui8_58">The App Engine scheduler decides whether to serve each new request with an existing instance (either one that is idle or accepts concurrent requests), put the request in a pending request queue, or start a new instance for that request. The decision takes into account the number of available instances, how quickly your application has been serving requests (its latency), and how long it takes to spin up a new instance.</p><p id="zflui8_59">Each instance has its own queue for incoming requests. App Engine monitors the number of requests waiting in each instance's queue. If App Engine detects that queues for an application are getting too long due to increased load, it automatically creates a new instance of the application to handle that load.</p><p id="zflui8_60">App Engine also scales instances in reverse when request volumes decrease. This scaling helps ensure that all of your application's current instances are being used to optimal efficiency and cost effectiveness.</p><p id="zflui8_61">When an application is not being used at all, App Engine turns off its associated dynamic instances, but readily reloads them as soon as they are needed. Reloading instances may result in loading requests and additional latency for users.</p><p id="zflui8_62">You can specify a minimum number of idle instances. Setting an appropriate number of idle instances for your application based on request volume allows your application to serve every request with little latency, unless you are experiencing abnormally high request volume.</p></section><section class="chapter"><h2 id="request-throughput-and-latency" data-toc="request-throughput-and-latency">Request throughput and latency</h2><p id="zflui8_63">Your application's latency has the biggest impact on the number of instances needed to serve your traffic. If you process requests quickly, a single instance can handle a lot of requests.</p><p id="zflui8_64">Single-threaded instances (Python or Java) can currently handle one concurrent request. Therefore, there is a direct relationship between the latency and number of requests that can be handled on the instance per second. For example, 10ms latency equals 100 request/second/instance, 100ms latency equals 10 request/second/instance, etc. Multi-threaded instances can handle many concurrent requests. Therefore, there is a direct relationship between the CPU consumed and the number of requests/second.</p><p id="zflui8_65"><a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/java/config/appconfig#Java_appengine_web_xml_Using_concurrent_requests" id="zflui8_67" data-external="true" rel="noopener noreferrer" target="_blank">Java</a> and <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/python/config/appconfig#Python_app_yaml_Using_concurrent_requests" id="zflui8_68" data-external="true" rel="noopener noreferrer" target="_blank">Python 2.7</a> apps support concurrent requests, so a single instance can handle new requests while waiting for other requests to complete. Concurrency significantly reduces the number of instances your app requires, but you need to design your app specifically with multithreading in mind.</p><p id="zflui8_66">For example, if a <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/java/modules/#Java_Instance_scaling_and_class" id="zflui8_69" data-external="true" rel="noopener noreferrer" target="_blank">B4 instance</a> (approx 2.4GHz) consumes 10 Mcycles/request, you can process 240 requests/second/instance. If it consumes 100 Mcycles/request, you can process 24 requests/second/instance, etc. These numbers are the ideal case but are fairly realistic in terms of what you can accomplish on an instance. Multi-Threaded instances are not available for the Python 2.5 runtime.</p></section><section class="chapter"><h2 id="special-kinds-of-requests" data-toc="special-kinds-of-requests">Special kinds of requests</h2><section class="chapter"><h3 id="loading-requests" data-toc="loading-requests">Loading requests</h3><p id="zflui8_72">When App Engine creates a new instance for your application, the instance must first load any libraries and resources required to handle the request. This happens during the first request to the instance, called a <span class="emphasis" id="zflui8_75">Loading Request</span>. During a loading request, your application undergoes initialization which causes the request to take longer.</p><p id="zflui8_73">The following best practices allow you to reduce the duration of loading requests:</p><ul class="list _bullet" id="zflui8_74"><li class="list__item" id="zflui8_76"><p id="zflui8_79">Load only the code needed for startup.</p></li><li class="list__item" id="zflui8_77"><p id="zflui8_80">Access the disk as little as possible.</p></li><li class="list__item" id="zflui8_78"><p id="zflui8_81">In some cases, loading code from a zip or jar file is faster than loading from many separate files.</p></li></ul></section><section class="chapter"><h3 id="warmup-requests" data-toc="warmup-requests">Warmup requests</h3><p id="zflui8_82">Warmup requests are a specific type of loading request that load application code into an instance ahead of time, before any live requests are made. To learn more about how to use warmup requests, see <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/docs/java/config/appconfig#Java_Warmup_requests" id="zflui8_84" data-external="true" rel="noopener noreferrer" target="_blank">Warmup Requests</a>.</p><p id="zflui8_83"><span class="control" id="zflui8_85">Note:</span> Warmup requests are not always called for every new instance. For example, if the new instance is the very first instance of your application, the user's request is sent to the application directly. As a result, you may still encounter loading requests, even with warmup requests enabled.</p></section></section><section class="chapter"><h2 id="instance-billing" data-toc="instance-billing">Instance billing</h2><p id="zflui8_86">In general, instances are charged per-minute for their uptime in addition to a 15-minute startup fee. Billing begins when the instance starts and ends fifteen minutes after the instance shuts down (see <a href="https://web.archive.org/web/20160424230901/https://cloud.google.com/appengine/pricing" id="zflui8_89" data-external="true" rel="noopener noreferrer" target="_blank">Pricing</a> for details). You will be billed only for idle instances up to the number of maximum idle instances that you set for each module. Runtime overhead is counted against the instance memory . This will be higher for Java applications than Python.</p><p id="zflui8_87">Billing is slightly different in resident and dynamic instances:</p><ul class="list _bullet" id="zflui8_88"><li class="list__item" id="zflui8_90"><p id="zflui8_92">For resident instances, billing ends fifteen minutes after the instance is shut down.</p></li><li class="list__item" id="zflui8_91"><p id="zflui8_93">For dynamic instances, billing ends fifteen minutes after the last request has finished processing.</p></li></ul></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="routing-requests-to-modules.html" class="navigation-links__prev">Routing Requests to Modules</a><a href="resources.html" class="navigation-links__next">Resources</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>