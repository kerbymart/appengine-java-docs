<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:45.371082144"><title>Search Best Practices | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"batch-index-put-and-index-delete-calls","level":0,"title":"Batch Index.put() and Index.delete() calls","anchor":"#batch-index-put-and-index-delete-calls"},{"id":"use-document-rank-to-pre-sort-documents","level":0,"title":"Use document rank to pre-sort documents","anchor":"#use-document-rank-to-pre-sort-documents"},{"id":"use-atom-fields-for-boolean-data","level":0,"title":"Use atom fields for boolean data","anchor":"#use-atom-fields-for-boolean-data"},{"id":"turn-negatives-into-positives","level":0,"title":"Turn negatives into positives","anchor":"#turn-negatives-into-positives"},{"id":"turn-disjunctions-into-conjunctions","level":0,"title":"Turn disjunctions into conjunctions","anchor":"#turn-disjunctions-into-conjunctions"},{"id":"eliminate-tautologies-from-your-queries","level":0,"title":"Eliminate tautologies from your queries","anchor":"#eliminate-tautologies-from-your-queries"},{"id":"narrow-the-range-before-sorting","level":0,"title":"Narrow the range before sorting","anchor":"#narrow-the-range-before-sorting"},{"id":"use-narrow-categories-to-avoid-or-minimize-sorting","level":0,"title":"Use narrow categories to avoid or minimize sorting","anchor":"#use-narrow-categories-to-avoid-or-minimize-sorting"},{"id":"do-not-score-matches-unless-you-need-to","level":0,"title":"Do not score matches unless you need to","anchor":"#do-not-score-matches-unless-you-need-to"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Search Best Practices | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/search-best-practices.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Search Best Practices | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/search-best-practices.html#webpage",
    "url": "writerside-documentation/search-best-practices.html",
    "name": "Search Best Practices | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Search-Best-Practices" data-main-title="Search Best Practices" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Searchable-Document-Indexes.md|Searchable Document Indexes"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Search-Best-Practices" id="Search-Best-Practices.md">Search Best Practices</h1><p id="euvnpl_3">This document recommends best practices for the Search API. We use single quotes (&lsquo;&rsquo;) throughout to delimit query strings. This way a query that contains multi-word phrases surrounded by double quotes can be delimited without confusion: <code class="code" id="euvnpl_13">&lsquo;field:&quot;some text&quot; some-value&rsquo;</code>.</p><section class="chapter"><h2 id="batch-index-put-and-index-delete-calls" data-toc="batch-index-put-and-index-delete-calls">Batch Index.put() and Index.delete() calls</h2><p id="euvnpl_14">You can pass up to 200 documents at a time when adding or deleting them from an index. This is much more efficient than handling them one at a time.</p></section><section class="chapter"><h2 id="use-document-rank-to-pre-sort-documents" data-toc="use-document-rank-to-pre-sort-documents">Use document rank to pre-sort documents</h2><p id="euvnpl_15">By default, search returns its results by descending rank. Also by default, the Search API sets the rank of each document to seconds since Jan 1st 2011. This results in the freshest documents being returned first. However, if you don&rsquo;t need documents to be sorted by the time they were added, you can use rank for other purposes. Suppose you have a real estate application. What customers want most is sorting by price. For an efficient default sort, you could set the rank to the house price.</p><p id="euvnpl_16">If you need multiple sort orders such as price low-to-high and price high-to-low, you can create a separate index for each order. One index would have rank = price and the other rank = MAXINT-price (since rank must be positive).</p><p id="euvnpl_17">Using rank as the sort key will improve search performance. To specify other sort keys, you must use sort options, which limits the number of search results to 10,000 documents. In this case, the sort order determined by rank will determine which documents will be included in the sort. Read about <a href="https://web.archive.org/web/20160424230344/https://cloud.google.com/appengine/docs/java/search/options#Java_SortOptions" id="euvnpl_18" data-external="true" rel="noopener noreferrer" target="_blank">sort options</a> to learn more.</p></section><section class="chapter"><h2 id="use-atom-fields-for-boolean-data" data-toc="use-atom-fields-for-boolean-data">Use atom fields for boolean data</h2><p id="euvnpl_19">Storing boolean data in number fields is very inefficient. Use atom fields instead, and assign your favorite constants (True/False, yes/no, 0/1).</p></section><section class="chapter"><h2 id="turn-negatives-into-positives" data-toc="turn-negatives-into-positives">Turn negatives into positives</h2><p id="euvnpl_20">Suppose you have a special term to identify restaurants whose cuisine is undefined. If you want to exclude those restaurants you could use <code class="code" id="euvnpl_21">&lsquo;NOT cuisine:undefined&rsquo;</code> as your query. This is, however, more expensive to evaluate (in both billable operations and computation time) than having the opposite, finding restaurants whose cuisine is known. Rather than having one field, cuisine, you can use two, <code class="code" id="euvnpl_22">cuisine</code>, and <code class="code" id="euvnpl_23">cuisine_known</code>, with the latter being an atom field. For restaurants for which cuisine is defined, you set the first field to the actual cuisine and the second field to <code class="code" id="euvnpl_24">&quot;yes&quot;</code>. For restaurants for which you do not know the cuisine, you set cuisine to <code class="code" id="euvnpl_25">&quot;&quot;</code> (an empty string) and <code class="code" id="euvnpl_26">cuisine_known</code> to <code class="code" id="euvnpl_27">&quot;no&quot;</code>. Now to find restaurants for which cuisine is known you issue a query <code class="code" id="euvnpl_28">&lsquo;cuisine_known:yes&rsquo;</code>, which is much faster than the negation.</p></section><section class="chapter"><h2 id="turn-disjunctions-into-conjunctions" data-toc="turn-disjunctions-into-conjunctions">Turn disjunctions into conjunctions</h2><p id="euvnpl_29">The &quot;OR&quot; disjunction is an expensive operation in both billable operations and computation time. Suppose you want to search for <code class="code" id="euvnpl_30">&lsquo;cuisine:Japanese OR cuisine:Korean&rsquo;</code>. An alternative is to index documents with more general categories of cuisine. In this case, the query may be simplified to <code class="code" id="euvnpl_31">&lsquo;cuisine:Asian&rsquo;</code>.</p></section><section class="chapter"><h2 id="eliminate-tautologies-from-your-queries" data-toc="eliminate-tautologies-from-your-queries">Eliminate tautologies from your queries</h2><p id="euvnpl_32">Suppose you want to find all restaurants in Toronto. Assuming that your documents have only a single field named &quot;city&quot;, if you use the query <code class="code" id="euvnpl_33">&lsquo;city:toronto AND NOT city:montreal&rsquo;</code> you get the same results as <code class="code" id="euvnpl_34">&lsquo;city:toronto&rsquo;</code>, because if city is set to <code class="code" id="euvnpl_35">&quot;toronto&quot;</code> it cannot be set to <code class="code" id="euvnpl_36">&quot;montreal&quot;</code>. The second query runs much faster since it involves only one term. The first query performs three steps: first, it finds a list of documents where city is set to &quot;toronto&quot;, then it finds a list of all cities for where city is not set to &quot;montreal&quot;, and finally it computes the intersection of the two lists.</p></section><section class="chapter"><h2 id="narrow-the-range-before-sorting" data-toc="narrow-the-range-before-sorting">Narrow the range before sorting</h2><p id="euvnpl_37">Suppose your application stores information about restaurants around the world, and you would like to show the restaurants closest to the current user. One way of doing this is to sort matching documents by the distance from the user&rsquo;s location. But if you have 1,000,000 restaurants, running a query like <code class="code" id="euvnpl_38">&lsquo;cuisine:japanese&rsquo;</code> with the sort expression distance(geopoint(x, y), restaurant_loc) will take a long time. It's a good idea to add filters to a query so that you start with a more salient set of selected documents to sort. One solution is to create geographical categories, such as country, state and city - you could infer city and state from the user&rsquo;s location. Then your query becomes <code class="code" id="euvnpl_39">&lsquo;cuisine:japanese AND city:&lt;user-city&gt;&rsquo;</code>. Chances are very good that you'll no longer need to sort 1,000,000 documents.</p></section><section class="chapter"><h2 id="use-narrow-categories-to-avoid-or-minimize-sorting" data-toc="use-narrow-categories-to-avoid-or-minimize-sorting">Use narrow categories to avoid or minimize sorting</h2><p id="euvnpl_40">If you use rank to sort restaurants by price, you could create a <code class="code" id="euvnpl_41">price_range</code> field that contains price categories: <code class="code" id="euvnpl_42">price_0_10</code>, <code class="code" id="euvnpl_43">price_11_20</code>, <code class="code" id="euvnpl_44">price_21_30</code>, <code class="code" id="euvnpl_45">price_31_40</code>, <code class="code" id="euvnpl_46">price_41_lots</code>. You could then find all restaurants that cost between <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="5.993ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 2649 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(1000,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1529,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2129,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container>40 with no sorting at all using the query <code class="code" id="euvnpl_48">&lsquo;price_range:price_21_30 OR price_range:price_31_40&rsquo;</code>. In many cases the appropriate categories are not as clear-cut, but with this technique you can reject a large number of documents before winnowing down the search with expensive queries such as <code class="code" id="euvnpl_49">&lsquo;... AND price&gt;25 AND price&lt;35&rsquo;</code>.</p></section><section class="chapter"><h2 id="do-not-score-matches-unless-you-need-to" data-toc="do-not-score-matches-unless-you-need-to">Do not score matches unless you need to</h2><p id="euvnpl_50">Scoring is used to indicate how well a given document matched a query. However, unless you intend to sort by score, do not request scoring. It will only slow down your search.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="faceted-search.html" class="navigation-links__prev">Faceted Search</a><a href="using-the-java-development-server.html" class="navigation-links__next">Using the Java Development Server</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>