<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:45.656606814"><title>Java Datastore API | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"contents","level":0,"title":"Contents","anchor":"#contents"},{"id":"comparison-with-traditional-databases","level":0,"title":"Comparison with traditional databases","anchor":"#comparison-with-traditional-databases"},{"id":"entities","level":0,"title":"Entities","anchor":"#entities"},{"id":"queries-and-indexes","level":0,"title":"Queries and indexes","anchor":"#queries-and-indexes"},{"id":"transactions","level":0,"title":"Transactions","anchor":"#transactions"},{"id":"datastore-writes-and-data-visibility","level":0,"title":"Datastore writes and data visibility","anchor":"#datastore-writes-and-data-visibility"},{"id":"datastore-statistics","level":0,"title":"Datastore statistics","anchor":"#datastore-statistics"},{"id":"quotas-and-limits","level":0,"title":"Quotas and limits","anchor":"#quotas-and-limits"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Java Datastore API | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/java-datastore-api.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Java Datastore API | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/java-datastore-api.html#webpage",
    "url": "writerside-documentation/java-datastore-api.html",
    "name": "Java Datastore API | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Java-Datastore-API" data-main-title="Java Datastore API" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Storing-Data.md|Storing Data///Google-Cloud-Datastore.md|Google Cloud Datastore"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Java-Datastore-API" id="Java-Datastore-API.md">Java Datastore API</h1><p id="-pu4fn0_3"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/python/datastore/" id="-pu4fn0_22" data-tooltip="View this page in the Python runtime" data-external="true" rel="noopener noreferrer" target="_blank">Python</a> |Java |PHP |<a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/go/datastore/" id="-pu4fn0_23" data-tooltip="View this page in the Go runtime" data-external="true" rel="noopener noreferrer" target="_blank">Go</a></p><p id="-pu4fn0_4">Related videos</p><p id="-pu4fn0_5"><a href="https://web.archive.org/web/20160424225851/http://stackoverflow.com/questions/tagged/google-app-engine+gae-datastore" id="-pu4fn0_24" data-external="true" rel="noopener noreferrer" target="_blank"><figure id="-pu4fn0_25"><img alt="Stack overflow questions" src="https://web.archive.org/web/20160424225851im_/https://cloud.google.com/cloud/images/stack_overflow_questions.png" title="Stack Overflow Questions" width="240" height="53"></figure></a></p><p id="-pu4fn0_6"><a href="https://web.archive.org/web/20160424225851/http://stackoverflow.com/feeds/tag?sort=votes&amp;tagnames=google-app-engine%2Bgae-datastore" id="-pu4fn0_26" data-external="true" rel="noopener noreferrer" target="_blank">https://web.archive.org/web/20160424225851/http://stackoverflow.com/feeds/tag?sort=votes&amp;tagnames=google-app-engine%2Bgae-datastore</a></p><p id="-pu4fn0_7"></p><p id="-pu4fn0_8"><a href="https://web.archive.org/web/20160424225851/http://stackoverflow.com/questions/tagged/google-app-engine+gae-datastore?sort=votes" id="-pu4fn0_27" data-external="true" rel="noopener noreferrer" target="_blank">See more...</a></p><p id="-pu4fn0_9">App Engine Datastore is a schemaless <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/NoSQL" id="-pu4fn0_28" data-external="true" rel="noopener noreferrer" target="_blank">NoSQL</a> datastore providing robust, scalable storage for your web application, with the following features:</p><ul class="list _bullet" id="-pu4fn0_10"><li class="list__item" id="-pu4fn0_29"><p id="-pu4fn0_34">No planned downtime</p></li><li class="list__item" id="-pu4fn0_30"><p id="-pu4fn0_35">Atomic transactions</p></li><li class="list__item" id="-pu4fn0_31"><p id="-pu4fn0_36">High availability of reads and writes</p></li><li class="list__item" id="-pu4fn0_32"><p id="-pu4fn0_37">Strong consistency for reads and ancestor queries</p></li><li class="list__item" id="-pu4fn0_33"><p id="-pu4fn0_38">Eventual consistency for all other queries</p></li></ul><p id="-pu4fn0_11">You can access the Datastore using the low-level API described throughout the Datastore documentation, which provides direct access to all of Datastore's features, or you can use one of the higher-level open-source APIs for Datastore that provide ORM-like features and a more abstract experience, such as <a href="https://web.archive.org/web/20160424225851/https://github.com/objectify/objectify" id="-pu4fn0_39" data-external="true" rel="noopener noreferrer" target="_blank">Objectify</a>. Note that while the low-level Datastore API is provided and supported by Google, Objectify is provided by a third-party, and Google does not provide support for it.</p><p id="-pu4fn0_12">The Datastore replicates data across multiple datacenters. This provides a high level of availability for reads and writes. Most queries are <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/Eventual_consistency" id="-pu4fn0_40" data-external="true" rel="noopener noreferrer" target="_blank">eventually consistent</a>.</p><p id="-pu4fn0_13">The Datastore holds data objects known as <span class="emphasis" id="-pu4fn0_41">entities</span>. An entity has one or more <span class="emphasis" id="-pu4fn0_42">properties</span>, named values of one of several supported data types: for instance, a property can be a string, an integer, or a reference to another entity. Each entity is identified by its <span class="emphasis" id="-pu4fn0_43">kind</span>, which categorizes the entity for the purpose of queries, and a <span class="emphasis" id="-pu4fn0_44">key</span> that uniquely identifies it within its kind. The Datastore can execute multiple operations in a single <span class="emphasis" id="-pu4fn0_45">transaction</span>. By definition, a transaction cannot succeed unless every one of its operations succeeds; if any of the operations fails, the transaction is automatically rolled back. This is especially useful for distributed web applications, where multiple users may be accessing or manipulating the same data at the same time.</p><section class="chapter"><h2 id="contents" data-toc="contents">Contents</h2><ol class="list _decimal" id="-pu4fn0_46" type="1"><li class="list__item" id="-pu4fn0_47"><p id="-pu4fn0_54"><span id="-pu4fn0_55">Comparison with traditional databases</span></p></li><li class="list__item" id="-pu4fn0_48"><p id="-pu4fn0_56"><span id="-pu4fn0_58">Entities</span></p><ol class="list _decimal" id="-pu4fn0_57" type="1"><li class="list__item" id="-pu4fn0_59"><p id="-pu4fn0_61"><span id="-pu4fn0_62">Kinds, keys, and identifiers</span></p></li><li class="list__item" id="-pu4fn0_60"><p id="-pu4fn0_63"><span id="-pu4fn0_64">Ancestor paths</span></p></li></ol></li><li class="list__item" id="-pu4fn0_49"><p id="-pu4fn0_65"><span id="-pu4fn0_66">Queries and indexes</span></p></li><li class="list__item" id="-pu4fn0_50"><p id="-pu4fn0_67"><span id="-pu4fn0_69">Transactions</span></p><ol class="list _decimal" id="-pu4fn0_68" type="1"><li class="list__item" id="-pu4fn0_70"><p id="-pu4fn0_72"><span id="-pu4fn0_73">Transactions and entity groups</span></p></li><li class="list__item" id="-pu4fn0_71"><p id="-pu4fn0_74"><span id="-pu4fn0_75">Cross-group transactions</span></p></li></ol></li><li class="list__item" id="-pu4fn0_51"><p id="-pu4fn0_76"><span id="-pu4fn0_77">Datastore writes and data visibility</span></p></li><li class="list__item" id="-pu4fn0_52"><p id="-pu4fn0_78"><span id="-pu4fn0_79">Datastore statistics</span></p></li><li class="list__item" id="-pu4fn0_53"><p id="-pu4fn0_80"><span id="-pu4fn0_81">Quotas and limits</span></p></li></ol></section><section class="chapter"><h2 id="comparison-with-traditional-databases" data-toc="comparison-with-traditional-databases">Comparison with traditional databases</h2><p id="-pu4fn0_82">Unlike traditional relational databases, the Datastore uses a distributed architecture to automatically manage scaling to very large data sets. While the Datastore interface has many of the same features as traditional databases, it differs from them in the way it describes relationships between data objects. Entities of the same kind can have different properties, and different entities can have properties with the same name but different value types.</p><p id="-pu4fn0_83">These unique characteristics imply a different way of designing and managing data to take advantage of the ability to scale automatically. In particular, the Datastore differs from a traditional <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/Relational_database" id="-pu4fn0_85" data-external="true" rel="noopener noreferrer" target="_blank">relational database</a> in the following important ways:</p><ul class="list _bullet" id="-pu4fn0_84"><li class="list__item" id="-pu4fn0_86"><p id="-pu4fn0_89">The Datastore is designed to scale, allowing applications to maintain high performance as they receive more traffic:</p><ul class="list _bullet" id="-pu4fn0_90"><li class="list__item" id="-pu4fn0_91"><p id="-pu4fn0_93">Datastore writes scale by automatically distributing data as necessary.</p></li><li class="list__item" id="-pu4fn0_92"><p id="-pu4fn0_94">Datastore reads scale because the only queries supported are those whose performance scales with the size of the result set (as opposed to the data set). This means that a query whose result set contains 100 entities performs the same whether it searches over a hundred entities or a million. This property is the key reason some types of queries are not supported.</p></li></ul></li><li class="list__item" id="-pu4fn0_87"><p id="-pu4fn0_95">Because all queries are served by pre-built <span id="-pu4fn0_97">indexes</span>, the types of queries that can be executed are more restrictive than those allowed on a relational database with SQL. In particular, the following are not supported:</p><ul class="list _bullet" id="-pu4fn0_96"><li class="list__item" id="-pu4fn0_98"><p id="-pu4fn0_101">Join operations</p></li><li class="list__item" id="-pu4fn0_99"><p id="-pu4fn0_102">Inequality filtering on multiple properties</p></li><li class="list__item" id="-pu4fn0_100"><p id="-pu4fn0_103">Filtering of data based on results of a subquery</p></li></ul></li><li class="list__item" id="-pu4fn0_88"><p id="-pu4fn0_104">Unlike traditional relational databases, the Datastore doesn't require entities of the same kind to have a consistent property set (although you can choose to enforce such a requirement in your own application code).</p></li></ul></section><section class="chapter"><h2 id="entities" data-toc="entities">Entities</h2><p id="-pu4fn0_105">Objects in the Datastore are known as <span class="emphasis" id="-pu4fn0_109">entities</span>. An entity has one or more named <span class="emphasis" id="-pu4fn0_110">properties</span>, each of which can have one or more values. Property values can belong to <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Properties_and_value_types" id="-pu4fn0_111" data-external="true" rel="noopener noreferrer" target="_blank">a variety of data types</a>, including integers, floating-point numbers, strings, dates, and binary data, among others. A query on a property with multiple values tests whether any of the values meets the query criteria. This makes such properties useful for membership testing.</p><p id="-pu4fn0_106"><span class="control" id="-pu4fn0_112">Note:</span> Datastore entities are <span class="emphasis" id="-pu4fn0_113">schemaless</span>: unlike traditional relational databases, the Datastore does not require that all entities of a given kind have the same properties or that all of an entity's values for a given property be of the same data type. If a formal schema is needed, the application itself is responsible for ensuring that entities conform to it.</p><section class="chapter"><h3 id="kinds-keys-and-identifiers" data-toc="kinds-keys-and-identifiers">Kinds, keys, and identifiers</h3><p id="-pu4fn0_114">Each Datastore entity is of a particular <span class="emphasis" id="-pu4fn0_119">kind,</span> which categorizes the entity for the purpose of queries; for instance, a human resources application might represent each employee at a company with an entity of kind <code class="code" id="-pu4fn0_120">Employee</code>. In addition, each entity has its own <span class="emphasis" id="-pu4fn0_121">key</span>, which uniquely identifies it. The key consists of the following components:</p><ul class="list _bullet" id="-pu4fn0_115"><li class="list__item" id="-pu4fn0_122"><p id="-pu4fn0_125">The entity's kind</p></li><li class="list__item" id="-pu4fn0_123"><p id="-pu4fn0_126">An <span class="emphasis" id="-pu4fn0_128">identifier</span>, which can be either</p><ul class="list _bullet" id="-pu4fn0_127"><li class="list__item" id="-pu4fn0_129"><p id="-pu4fn0_131">a <span class="emphasis" id="-pu4fn0_132">key name</span> string</p></li><li class="list__item" id="-pu4fn0_130"><p id="-pu4fn0_133">an integer <span class="emphasis" id="-pu4fn0_134">ID</span></p></li></ul></li><li class="list__item" id="-pu4fn0_124"><p id="-pu4fn0_135">An optional <span id="-pu4fn0_136"><span class="emphasis" id="-pu4fn0_137">ancestor path</span></span> locating the entity within the Datastore hierarchy</p></li></ul><p id="-pu4fn0_116">The identifier is assigned when the entity is created. Because it is part of the entity's key, it is associated permanently with the entity and cannot be changed. It can be assigned in either of two ways:</p><ul class="list _bullet" id="-pu4fn0_117"><li class="list__item" id="-pu4fn0_138"><p id="-pu4fn0_140">Your application can specify its own key name string for the entity.</p></li><li class="list__item" id="-pu4fn0_139"><p id="-pu4fn0_141">You can have the Datastore automatically assign the entity an integer numeric ID.</p></li></ul><p id="-pu4fn0_118"><span class="control" id="-pu4fn0_142">Note:</span> Instead of using key name strings or generating numeric IDs automatically, advanced applications may sometimes wish to assign their own numeric IDs manually to the entities they create. Be aware, however, that if you choose this option you must take special steps to prevent your manually assigned numeric IDs from conflicting with those assigned automatically by the Datastore; see the <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Kinds_and_identifiers" id="-pu4fn0_143" data-external="true" rel="noopener noreferrer" target="_blank">Entities, Properties, and Keys</a> page for further details.</p></section><section class="chapter"><h3 id="ancestor-paths" data-toc="ancestor-paths">Ancestor paths</h3><p id="-pu4fn0_144">Entities in the Datastore form a hierarchically structured space similar to the directory structure of a file system. When you create an entity, you can optionally designate another entity as its <span class="emphasis" id="-pu4fn0_151">parent;</span> the new entity is a <span class="emphasis" id="-pu4fn0_152">child</span> of the parent entity (note that unlike in a file system, the parent entity need not actually exist). An entity without a parent is a <span class="emphasis" id="-pu4fn0_153">root entity.</span> The association between an entity and its parent is permanent, and cannot be changed once the entity is created. The Datastore will never assign the same numeric ID to two entities with the same parent, or to two root entities (those without a parent).</p><p id="-pu4fn0_145">An entity's parent, parent's parent, and so on recursively, are its <span class="emphasis" id="-pu4fn0_154">ancestors;</span> its children, children's children, and so on, are its <span class="emphasis" id="-pu4fn0_155">descendants.</span> A root entity and all of its descendants belong to the same <span class="emphasis" id="-pu4fn0_156">entity group.</span> The sequence of entities beginning with a root entity and proceeding from parent to child, leading to a given entity, constitute that entity's <span class="emphasis" id="-pu4fn0_157">ancestor path.</span> The complete key identifying the entity consists of a sequence of kind-identifier pairs specifying its ancestor path and terminating with those of the entity itself:</p><div class="code-block" data-lang="none">
[Person:GreatGrandpa, Person:Grandpa, Person:Dad, Person:Me]
</div><p id="-pu4fn0_147">For a root entity, the ancestor path is empty and the key consists solely of the entity's own kind and identifier:</p><div class="code-block" data-lang="none">
[Person:GreatGrandpa]
</div><p id="-pu4fn0_149">This concept is illustrated by the following diagram:</p><figure id="-pu4fn0_150"><img alt="Entity group" src="https://web.archive.org/web/20160424225851im_/https://cloud.google.com/images/products/clouddatastore/entity-group.png" title="Entity group" width="450"></figure></section></section><section class="chapter"><h2 id="queries-and-indexes" data-toc="queries-and-indexes">Queries and indexes</h2><p id="-pu4fn0_158">In addition to retrieving entities from the Datastore directly by their keys, an application can perform a <span class="emphasis" id="-pu4fn0_167"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries" id="-pu4fn0_174" data-external="true" rel="noopener noreferrer" target="_blank">query</a></span> to retrieve them by the values of their properties. The query operates on entities of a given <span class="emphasis" id="-pu4fn0_168"><span id="-pu4fn0_175">kind</span></span>; it can specify <span class="emphasis" id="-pu4fn0_169"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Filters" id="-pu4fn0_176" data-external="true" rel="noopener noreferrer" target="_blank">filters</a></span> on the entities' property values, keys, and ancestors, and can return zero or more entities as <span class="emphasis" id="-pu4fn0_170">results.</span> A query can also specify <span class="emphasis" id="-pu4fn0_171"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Sort_orders" id="-pu4fn0_177" data-external="true" rel="noopener noreferrer" target="_blank">sort orders</a></span> to sequence the results by their property values. The results include all entities that have at least one (possibly null) value for every property named in the filters and sort orders, and whose property values meet all the specified filter criteria. The query can return entire entities, <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/projectionqueries" id="-pu4fn0_172" data-external="true" rel="noopener noreferrer" target="_blank">projected entities</a>, or just entity <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/#Java_Kinds_keys_and_identifiers" id="-pu4fn0_173" data-external="true" rel="noopener noreferrer" target="_blank">keys</a>.</p><p id="-pu4fn0_159">A typical query includes the following:</p><ul class="list _bullet" id="-pu4fn0_160"><li class="list__item" id="-pu4fn0_178"><p id="-pu4fn0_181">An <span class="emphasis" id="-pu4fn0_182"><span id="-pu4fn0_183">entity kind</span></span> to which the query applies</p></li><li class="list__item" id="-pu4fn0_179"><p id="-pu4fn0_184">Zero or more <span class="emphasis" id="-pu4fn0_185"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Filters" id="-pu4fn0_186" data-external="true" rel="noopener noreferrer" target="_blank">filters</a></span> based on the entities' property values, keys, and ancestors</p></li><li class="list__item" id="-pu4fn0_180"><p id="-pu4fn0_187">Zero or more <span class="emphasis" id="-pu4fn0_188"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Sort_orders" id="-pu4fn0_189" data-external="true" rel="noopener noreferrer" target="_blank">sort orders</a></span> to sequence the results</p></li></ul><p id="-pu4fn0_161">When executed, the query retrieves all entities of the given kind that satisfy all of the given filters, sorted in the specified order. Queries execute as read-only.</p><p id="-pu4fn0_162"><span class="control" id="-pu4fn0_190">Note:</span> To conserve memory and improve performance, a query should, whenever possible, specify a limit on the number of results returned.</p><p id="-pu4fn0_163">A query can also include an <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Ancestor_filters" id="-pu4fn0_191" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_196">ancestor filter</span></a> limiting the results to just the entity group descended from a specified ancestor. Such a query is known as an <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Ancestor_queries" id="-pu4fn0_192" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_197">ancestor query</span></a>. By default, ancestor queries return <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/Strong_consistency" id="-pu4fn0_193" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_198">strongly consistent</span></a> results, which are guaranteed to be up to date with the latest changes to the data. Non-ancestor queries, by contrast, can span the entire Datastore rather than just a single entity group, but are only <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/Eventual_consistency" id="-pu4fn0_194" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_199">eventually consistent</span></a> and may return stale results. If strong consistency is important to your application, you may need to take this into account when structuring your data, placing related entities in the same entity group so they can be retrieved with an ancestor rather than a non-ancestor query; see <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/structuring_for_strong_consistency" id="-pu4fn0_195" data-external="true" rel="noopener noreferrer" target="_blank">Structuring Data for Strong Consistency</a> for more information.</p><p id="-pu4fn0_164">Every Datastore query computes its results using one or more <span class="emphasis" id="-pu4fn0_200"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/indexes" id="-pu4fn0_201" data-external="true" rel="noopener noreferrer" target="_blank">indexes</a>,</span> which contain entity keys in a sequence specified by the index's properties and, optionally, the entity's ancestors. The indexes are updated incrementally to reflect any changes the application makes to its entities, so that the correct results of all queries are available with no further computation needed.</p><p id="-pu4fn0_165">App Engine predefines a simple index on each property of an entity. An App Engine application can define further custom indexes in an <span class="emphasis" id="-pu4fn0_202"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/config/indexconfig" id="-pu4fn0_205" data-external="true" rel="noopener noreferrer" target="_blank">index configuration file</a></span> named <code class="code" id="-pu4fn0_203">datastore-indexes.xml</code>, which is generated in your application's <code class="code" id="-pu4fn0_204">/war/WEB-INF/appengine-generated</code> directory. The development server automatically adds suggestions to this file as it encounters queries that cannot be executed with the existing indexes. You can tune indexes manually by editing the file before uploading the application.</p><p id="-pu4fn0_166"><span class="control" id="-pu4fn0_206">Note:</span> The index-based query mechanism supports a wide range of queries and is suitable for most applications. However, it does not support some kinds of query common in other database technologies: in particular, joins and aggregate queries aren't supported within the Datastore query engine. See the <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/queries#Java_Restrictions_on_queries" id="-pu4fn0_207" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Queries</a> page for limitations on Datastore queries.</p></section><section class="chapter"><h2 id="transactions" data-toc="transactions">Transactions</h2><p id="-pu4fn0_208">Every attempt to insert, update, or delete an entity takes place in the context of a <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/transactions" id="-pu4fn0_212" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_213">transaction</span></a>. A single transaction can include any number of such operations. To maintain the consistency of the data, the transaction ensures that all of the operations it contains are applied to the Datastore as a unit or, if any of the operations fails, that none of them are applied.</p><p id="-pu4fn0_209">You can perform multiple actions on an entity within a single transaction. For example, to increment a counter field in an object, you need to read the value of the counter, calculate the new value, and then store it back. Without a transaction, it is possible for another process to increment the counter between the time you read the value and the time you update it, causing your application to overwrite the updated value. Doing the read, calculation, and write in a single transaction ensures that no other process can interfere with the increment.</p><section class="chapter"><h3 id="transactions-and-entity-groups" data-toc="transactions-and-entity-groups">Transactions and entity groups</h3><p id="-pu4fn0_214">Only ancestor queries are allowed within a transaction: that is, each transactional query must be limited to a single entity group. The transaction itself can apply to multiple entities, which can belong either to a single entity group or (in the case of a <span id="-pu4fn0_216"><span class="emphasis" id="-pu4fn0_217">cross-group transaction</span></span>) to as many as twenty-five different entity groups.</p><p id="-pu4fn0_215">The Datastore uses <a href="https://web.archive.org/web/20160424225851/https://en.wikipedia.org/wiki/Optimistic_concurrency" id="-pu4fn0_218" data-external="true" rel="noopener noreferrer" target="_blank"><span class="emphasis" id="-pu4fn0_219">optimistic concurrency</span></a> to manage transactions. When two or more transactions try to change the same entity group at the same time (either updating existing entities or creating new ones), the first transaction to commit will succeed and all others will fail on commit. These other transactions can then be retried on the updated data. Note that this limits the number of concurrent writes you can do to any entity in a given entity group.</p></section><section class="chapter"><h3 id="cross-group-transactions" data-toc="cross-group-transactions">Cross-group transactions</h3><p id="-pu4fn0_220">A transaction on entities belonging to different entity groups is called a <span class="emphasis" id="-pu4fn0_224">cross-group (XG) transaction</span>. The transaction can be applied across a maximum of twenty-five entity groups, and will succeed as long as no concurrent transaction touches any of the entity groups to which it applies. This gives you more flexibility in organizing your data, because you aren't forced to put disparate pieces of data under the same ancestor just to perform atomic writes on them.</p><p id="-pu4fn0_221">As in a single-group transaction, you cannot perform a non-ancestor query in an XG transaction. You can, however, perform ancestor queries on separate entity groups. Nontransactional (non-ancestor) queries may see all, some, or none of the results of a previously committed transaction. (For background on this issue, see <span id="-pu4fn0_225">Datastore Writes and Data Visibility</span>.) However, such nontransactional queries are more likely to see the results of a partially committed XG transaction than those of a partially commited single-group transaction.</p><p id="-pu4fn0_222"><span class="control" id="-pu4fn0_226">Note:</span> The first read of an entity group in an XG transaction may throw a <a href="https://web.archive.org/web/20160424225851/http://download.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html" id="-pu4fn0_227" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-pu4fn0_228">ConcurrentModificationException</code></a> if there is a conflict with other transactions accessing that same entity group. This means that even an XG transaction that performs only reads can fail with a concurrency exception.</p><p id="-pu4fn0_223">An XG transaction that touches only a single entity group has exactly the same performance and cost as a single-group, non-XG transaction. In an XG transaction that touches multiple entity groups, operations cost the same as if they were performed in a non-XG transaction, but may experience higher latency.</p></section></section><section class="chapter"><h2 id="datastore-writes-and-data-visibility" data-toc="datastore-writes-and-data-visibility">Datastore writes and data visibility</h2><p id="-pu4fn0_229">Data is written to the Datastore in two phases:</p><ol class="list _decimal" id="-pu4fn0_230" type="1"><li class="list__item" id="-pu4fn0_235"><p id="-pu4fn0_237">In the Commit phase, the entity data is recorded in the transaction logs of a majority of replicas, and any replicas in which it was not recorded are marked as not having up-to-date logs.</p></li><li class="list__item" id="-pu4fn0_236"><p id="-pu4fn0_238">The Apply phase occurs independently in each replica, and consists of two actions performed in parallel:</p><ul class="list _bullet" id="-pu4fn0_239"><li class="list__item" id="-pu4fn0_240"><p id="-pu4fn0_242">The entity data is written in that replica.</p></li><li class="list__item" id="-pu4fn0_241"><p id="-pu4fn0_243">The index rows for the entity are written in that replica. (Note that this can take longer than writing the data itself.)</p></li></ul></li></ol><p id="-pu4fn0_231">The write operation returns immediately after the Commit phase and the Apply phase then takes place asynchronously, possibly at different times in each replica, and possibly with delays of a few hundred milliseconds or more from the completion of the Commit phase. If a failure occurs during the Commit phase, there are automatic retries; but if failures continue, the Datastore returns an error message that your application receives as an exception. If the Commit phase succeeds but the Apply fails in a particular replica, the Apply is rolled forward to completion in that replica when one of the following occurs:</p><ul class="list _bullet" id="-pu4fn0_232"><li class="list__item" id="-pu4fn0_244"><p id="-pu4fn0_246">Periodic Datastore sweeps check for uncompleted Commit jobs and apply them.</p></li><li class="list__item" id="-pu4fn0_245"><p id="-pu4fn0_247">Certain operations (<code class="code" id="-pu4fn0_248">get</code>, <code class="code" id="-pu4fn0_249">put</code>, <code class="code" id="-pu4fn0_250">delete</code>, and ancestor queries) that use the affected entity group cause any changes that have been committed but not yet applied to be completed in the replica in which they are executing before proceeding with the new operation.</p></li></ul><p id="-pu4fn0_233">This write behavior can have several implications on how and when data is visible to your application at different parts of the Commit and Apply phases:</p><ul class="list _bullet" id="-pu4fn0_234"><li class="list__item" id="-pu4fn0_251"><p id="-pu4fn0_255">If a write operation reports a timeout error, it cannot be determined (without attempting to read the data) whether the operation succeeded or failed.</p></li><li class="list__item" id="-pu4fn0_252"><p id="-pu4fn0_256">Because Datastore gets and ancestor queries apply any outstanding modifications to the replica on which they are executing, these operations always see a consistent view of all previous successful transactions. This means that a <code class="code" id="-pu4fn0_257">get</code> operation (looking up an updated entity by its key) is guaranteed to see the latest version of that entity.</p></li><li class="list__item" id="-pu4fn0_253"><p id="-pu4fn0_258">Non-ancestor queries may return stale results because they may be executing on a replica on which the latest transactions have not yet been applied. This can occur even if an operation was performed that is guaranteed to apply outstanding transactions because the query may execute on a different replica than the previous operation.</p></li><li class="list__item" id="-pu4fn0_254"><p id="-pu4fn0_259">The timing of concurrent changes may affect the results of non-ancestor queries. If an entity initially satisfies a query but is later changed so that it no longer does, the entity may still be included in the query's result set if the changes had not yet been applied to the indexes in the replica on which the query was executed.</p></li></ul></section><section class="chapter"><h2 id="datastore-statistics" data-toc="datastore-statistics">Datastore statistics</h2><p id="-pu4fn0_260">The Datastore maintains statistics about the data stored for an application, such as how many entities there are of a given kind or how much space is used by property values of a given type. You can view these statistics in the Cloud Platform Console <a href="https://web.archive.org/web/20160424225851/https://console.cloud.google.com/project/_/datastore/stats" id="-pu4fn0_261" data-external="true" rel="noopener noreferrer" target="_blank">Cloud Datastore dashboard</a> page. You can also use the Datastore API to access these values programmatically from within the application by querying for specially named entities; see <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/java/datastore/stats" id="-pu4fn0_262" data-external="true" rel="noopener noreferrer" target="_blank">Datastore Statistics in Java</a> for more information.</p></section><section class="chapter"><h2 id="quotas-and-limits" data-toc="quotas-and-limits">Quotas and limits</h2><p id="-pu4fn0_263">Various aspects of your application's Datastore usage are counted toward your resource quotas:</p><ul class="list _bullet" id="-pu4fn0_264"><li class="list__item" id="-pu4fn0_267"><p id="-pu4fn0_270">Data sent to the Datastore by the application counts toward the <span class="control" id="-pu4fn0_271">Data Sent to Datastore API</span> quota.</p></li><li class="list__item" id="-pu4fn0_268"><p id="-pu4fn0_272">Data received by the application from the Datastore counts toward the <span class="control" id="-pu4fn0_273">Data Received from Datastore API</span> quota.</p></li><li class="list__item" id="-pu4fn0_269"><p id="-pu4fn0_274">The total amount of data currently stored in the Datastore for the application cannot exceed the <span class="control" id="-pu4fn0_275"><a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/quotas#Storage" id="-pu4fn0_277" data-external="true" rel="noopener noreferrer" target="_blank">Stored Data (billable)</a></span> quota. This includes all entity properties and keys, as well as the indexes needed to support querying those entities. See the article <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/articles/storage_breakdown" id="-pu4fn0_276" data-external="true" rel="noopener noreferrer" target="_blank">How Entities and Indexes Are Stored</a> for a complete breakdown of the metadata required to store entities and indexes at the Bigtable level.</p></li></ul><p id="-pu4fn0_265">For information on systemwide safety limits, see the <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/quotas#Safety_Quotas_and_Billable_Quotas" id="-pu4fn0_278" data-external="true" rel="noopener noreferrer" target="_blank">Quotas and Limits</a> page and the quota details page in the <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/developers-console/#quotas" id="-pu4fn0_279" data-external="true" rel="noopener noreferrer" target="_blank">Cloud Platform Console</a>. In addition to such system-wide limits, the following limits apply specifically to the use of the Datastore:</p><div class="table-wrapper"><table class="wide" id="-pu4fn0_266"><thead><tr class="ijRowHead" id="-pu4fn0_280"><th id="-pu4fn0_285"><p>Limit</p></th><th id="-pu4fn0_286"><p>Amount</p></th></tr></thead><tbody><tr id="-pu4fn0_281"><td id="-pu4fn0_287"><p>Maximum entity size</p></td><td id="-pu4fn0_288"><p>1 megabyte</p></td></tr><tr id="-pu4fn0_282"><td id="-pu4fn0_289"><p>Maximum transaction size</p></td><td id="-pu4fn0_290"><p>10 megabytes</p></td></tr><tr id="-pu4fn0_283"><td id="-pu4fn0_291"><p>Maximum number of <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/python/datastore/indexes#Python_Index_limits" id="-pu4fn0_293" data-external="true" rel="noopener noreferrer" target="_blank">index entries</a> for an entity</p></td><td id="-pu4fn0_292"><p>20000</p></td></tr><tr id="-pu4fn0_284"><td id="-pu4fn0_294"><p>Maximum <a href="https://web.archive.org/web/20160424225851/https://cloud.google.com/appengine/docs/python/datastore/indexes#Python_Index_limits" id="-pu4fn0_296" data-external="true" rel="noopener noreferrer" target="_blank">number of bytes in composite indexes</a> for an entity</p></td><td id="-pu4fn0_295"><p>2 megabytes</p></td></tr></tbody></table></div></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="google-cloud-datastore.html" class="navigation-links__prev">Google Cloud Datastore</a><a href="entities-properties-and-keys.html" class="navigation-links__next">Entities, Properties, and Keys</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>