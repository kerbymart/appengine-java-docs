<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-13T01:56:44.329423084"><title>Managing App Resources | Google App Engine Java Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"viewing-usage-reports","level":0,"title":"Viewing usage reports","anchor":"#viewing-usage-reports"},{"id":"managing-dynamic-instance-scaling","level":0,"title":"Managing dynamic instance scaling","anchor":"#managing-dynamic-instance-scaling"},{"id":"managing-application-storage","level":0,"title":"Managing application storage","anchor":"#managing-application-storage"},{"id":"managing-datastore-usage","level":0,"title":"Managing datastore usage","anchor":"#managing-datastore-usage"},{"id":"managing-bandwidth","level":0,"title":"Managing bandwidth","anchor":"#managing-bandwidth"},{"id":"managing-other-resources","level":0,"title":"Managing other resources","anchor":"#managing-other-resources"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Managing App Resources | Google App Engine Java Documentation"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Google App Engine Java Documentation Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/managing-app-resources.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Managing App Resources | Google App Engine Java Documentation"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/managing-app-resources.html#webpage",
    "url": "writerside-documentation/managing-app-resources.html",
    "name": "Managing App Resources | Google App Engine Java Documentation",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Google App Engine Java Documentation Help"
}</script><!-- End Schema.org --></head><body data-id="Managing-App-Resources" data-main-title="Managing App Resources" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Guides.md|Guides///Managing-and-Configuring-Your-App.md|Managing and Configuring Your App"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Google App Engine Java Documentation  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Managing-App-Resources" id="Managing-App-Resources.md">Managing App Resources</h1><p id="z7crdbz_3"><a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/console/managing-resources" id="z7crdbz_12" data-tooltip="View this page in the Python runtime" data-external="true" rel="noopener noreferrer" target="_blank">Python</a> |Java |<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/php/console/managing-resources" id="z7crdbz_13" data-tooltip="View this page in the PHP runtime" data-external="true" rel="noopener noreferrer" target="_blank">PHP</a> |<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/go/console/managing-resources" id="z7crdbz_14" data-tooltip="View this page in the Go runtime" data-external="true" rel="noopener noreferrer" target="_blank">Go</a></p><p id="z7crdbz_4">App Engine generates usage reports to help you understand your application's performance and the resources your application is using. Based on these reports, you can employ the strategies listed below to manage your resources. After making any changes, you will see that information reflected in subsequent usage reports. For more information, please see our <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/pricing.html" id="z7crdbz_15" data-external="true" rel="noopener noreferrer" target="_blank">pricing</a> page.</p><ol class="list _decimal" id="z7crdbz_5" type="1"><li class="list__item" id="z7crdbz_16"><p id="z7crdbz_22"><span id="z7crdbz_23">Viewing usage reports</span></p></li><li class="list__item" id="z7crdbz_17"><p id="z7crdbz_24"><span id="z7crdbz_26">Managing dynamic instance scaling</span></p><ol class="list _decimal" id="z7crdbz_25" type="1"><li class="list__item" id="z7crdbz_27"><p id="z7crdbz_33"><span id="z7crdbz_34">Decreasing latency</span></p></li><li class="list__item" id="z7crdbz_28"><p id="z7crdbz_35"><span id="z7crdbz_36">Change auto scaling performance settings</span></p></li><li class="list__item" id="z7crdbz_29"><p id="z7crdbz_37"><span id="z7crdbz_38">Enable concurrent requests in Java</span></p></li><li class="list__item" id="z7crdbz_30"><p id="z7crdbz_39"><span id="z7crdbz_40">Enable concurrent requests in Python</span></p></li><li class="list__item" id="z7crdbz_31"><p id="z7crdbz_41"><span id="z7crdbz_42">Configuring TaskQueue settings</span></p></li><li class="list__item" id="z7crdbz_32"><p id="z7crdbz_43"><span id="z7crdbz_44">Serve static content where possible</span></p></li></ol></li><li class="list__item" id="z7crdbz_18"><p id="z7crdbz_45"><span id="z7crdbz_46">Managing application storage</span></p></li><li class="list__item" id="z7crdbz_19"><p id="z7crdbz_47"><span id="z7crdbz_48">Managing datastore usage</span></p></li><li class="list__item" id="z7crdbz_20"><p id="z7crdbz_49"><span id="z7crdbz_50">Managing bandwidth</span></p></li><li class="list__item" id="z7crdbz_21"><p id="z7crdbz_51"><span id="z7crdbz_52">Managing other resources</span></p></li></ol><section class="chapter"><h2 id="viewing-usage-reports" data-toc="viewing-usage-reports">Viewing usage reports</h2><p id="z7crdbz_53">When you evaluate the performance of your application, you will be interested in how many <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/scaling" id="z7crdbz_59" data-external="true" rel="noopener noreferrer" target="_blank">instances</a> it is running, and how it is consuming resources.</p><p id="z7crdbz_54"><a href="https://web.archive.org/web/20160424230521/https://console.cloud.google.com/appengine" id="z7crdbz_60" data-external="true" rel="noopener noreferrer" target="_blank">View the dashboard usage reports</a></p><p id="z7crdbz_55"><a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/console/#dashboard" id="z7crdbz_61" data-external="true" rel="noopener noreferrer" target="_blank">Learn more about the dashboard</a> that summarizes resource usage.</p><p id="z7crdbz_56"><a href="https://web.archive.org/web/20160424230521/https://console.cloud.google.com/appengine/instances" id="z7crdbz_62" data-external="true" rel="noopener noreferrer" target="_blank">View the Instances page</a></p><p id="z7crdbz_57"><a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/console/#instances" id="z7crdbz_63" data-external="true" rel="noopener noreferrer" target="_blank">Learn more about viewing instances</a> from the Cloud Platform Console.</p><p id="z7crdbz_58">The following sections suggest some strategies you can use to manage resources, and explain what these strategies could mean for your application's performance.</p></section><section class="chapter"><h2 id="managing-dynamic-instance-scaling" data-toc="managing-dynamic-instance-scaling">Managing dynamic instance scaling</h2><section class="chapter"><h3 id="decreasing-latency" data-toc="decreasing-latency">Decreasing latency</h3><p id="z7crdbz_70">Application latency has an impact on how many instances are required to handle your traffic. By decreasing latency, you can reduce the number of instances we use to serve your application. <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/trace/" id="z7crdbz_73" data-external="true" rel="noopener noreferrer" target="_blank">Google Cloud Trace</a> is a useful tool that you can use to view data about latency and understand what changes you can make to decrease it.</p><p id="z7crdbz_71">After you have used Cloud Trace to view your latency, you can to try some of the following strategies for reducing it:</p><ul class="list _bullet" id="z7crdbz_72"><li class="list__item" id="z7crdbz_74"><p id="z7crdbz_80"><span class="control" id="z7crdbz_81">Increase caching of frequently accessed shared data</span> - That&rsquo;s another way of saying - use Memcache. Also, if you set your application&rsquo;s cache-control headers, this can have a big impact on how efficiently your data is cached by servers and browsers. Even caching things for a few seconds can have a big impact on how efficiently your application serves traffic. Python applications should also make use of <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/#Python_App_caching" id="z7crdbz_82" data-external="true" rel="noopener noreferrer" target="_blank">caching in the runtime</a> as well.</p></li><li class="list__item" id="z7crdbz_75"><p id="z7crdbz_83"><span class="control" id="z7crdbz_84">Use Memcache more efficiently</span> - Use batch calls for get, set, delete, etc instead of a series of individual calls. Where appropriate, consider using the Memcache Async API (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/memcache/AsyncMemcacheService.html" id="z7crdbz_85" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/refdocs/google.appengine.api.memcache#google.appengine.api.memcache.Client" id="z7crdbz_86" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>).</p></li><li class="list__item" id="z7crdbz_76"><p id="z7crdbz_87"><span class="control" id="z7crdbz_88">Use Tasks for non-request bound functionality</span> - If your application performs work that can be done outside of the scope of a user-facing request, put it in a task! Sending this work to the Task Queue instead of waiting for it to complete before returning a response can significantly reduce user-facing latency. The Task Queue can then give you much more control over execution rates and help smooth out your load.</p></li><li class="list__item" id="z7crdbz_77"><p id="z7crdbz_89"><span class="control" id="z7crdbz_90">Use the datastore more efficiently</span> - We go in to more detail for this below.</p></li><li class="list__item" id="z7crdbz_78"><p id="z7crdbz_91"><span class="control" id="z7crdbz_93">Parallelize multiple URL Fetch calls</span></p><ul class="list _bullet" id="z7crdbz_92"><li class="list__item" id="z7crdbz_94"><p id="z7crdbz_97">Use the async URL Fetch API (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/urlfetch/URLFetchService#fetchAsync(com.google.appengine.api.urlfetch.HTTPRequest)" id="z7crdbz_98" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/urlfetch/asynchronousrequests" id="z7crdbz_99" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>).</p></li><li class="list__item" id="z7crdbz_95"><p id="z7crdbz_100">Use <a href="https://web.archive.org/web/20160424230521/http://golang.org/doc/effective_go.html#concurrency" id="z7crdbz_101" data-external="true" rel="noopener noreferrer" target="_blank">goroutines</a> (Go).</p></li><li class="list__item" id="z7crdbz_96"><p id="z7crdbz_102">Batch together multiple URL Fetch calls (which you might handle individually inside individual user facing requests) and handle them in an offline task in parallel via async URL Fetch.</p></li></ul></li><li class="list__item" id="z7crdbz_79"><p id="z7crdbz_103"><span class="control" id="z7crdbz_104">For Java HTTP sessions, write asynchronously</span> - HTTP sessions (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/appconfig#Java_appengine_web_xml_Enabling_sessions" id="z7crdbz_105" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>) lets you configure your application to asynchronously write HTTP session data to the datastore by adding <code class="code" id="z7crdbz_106">&lt;async-session-persistence enabled=&quot;true&quot;/&gt;</code> to your <code class="code" id="z7crdbz_107">appengine-web.xml</code>. Session data is always written synchronously to memcache, and if a request tries to read the session data when memcache is not available it will fail over to the datastore, which might not yet have the most recent update. This means there is a small risk your application will see stale session data, but for most applications the latency benefit far outweighs the risk.</p></li></ul></section><section class="chapter"><h3 id="change-auto-scaling-performance-settings" data-toc="change-auto-scaling-performance-settings">Change auto scaling performance settings</h3><p id="z7crdbz_108">The module configuration file contains two settings you can use to adjust the tradeoff between performance and resource load:</p><ul class="list _bullet" id="z7crdbz_109"><li class="list__item" id="z7crdbz_110"><p id="z7crdbz_112"><span class="control" id="z7crdbz_113">Max Idle Instances</span> - Setting <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/appconfig#max_idle_instances" id="z7crdbz_114" data-external="true" rel="noopener noreferrer" target="_blank">Max Idle Instances</a> allows App Engine to shut down idle instances above the specified limit so they won't consume additional quota or create charges. However, fewer idle instances also means that the App Engine Scheduler may have to spin up new instances if you experience a spike in traffic -- potentially increasing user-visible latency for your app.</p></li><li class="list__item" id="z7crdbz_111"><p id="z7crdbz_115"><span class="control" id="z7crdbz_116">Min Pending Latency</span> - Raising <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/appconfig#min_pending_latency" id="z7crdbz_117" data-external="true" rel="noopener noreferrer" target="_blank">Min Pending Latency</a> instructs App Engine&rsquo;s scheduler to not start a new instance unless a request has been pending for more than the specified time. If all instances are busy, user-facing requests may have to wait in the pending queue until this threshold is reached. Setting a high value for this setting will require fewer instances to be started, but may result in high user-visible latency during increased load.</p></li></ul></section><section class="chapter"><h3 id="enable-concurrent-requests-in-java" data-toc="enable-concurrent-requests-in-java">Enable concurrent requests in Java</h3><p id="z7crdbz_118">In our <a href="https://web.archive.org/web/20160424230521/http://code.google.com/p/googleappengine/wiki/SdkForJavaReleaseNotes" id="z7crdbz_119" data-external="true" rel="noopener noreferrer" target="_blank">1.4.3 release</a>, we introduced the ability for your application's instances to serve multiple requests concurrently in Java. Enabling this setting will decrease the number of instances needed to serve traffic for your application, but your application must be threadsafe in order for this to work correctly. Read about how to enable concurrent requests in our <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/appconfig#Java_appengine_web_xml_Using_concurrent_requests" id="z7crdbz_120" data-external="true" rel="noopener noreferrer" target="_blank">Java documentation</a>.</p></section><section class="chapter"><h3 id="enable-concurrent-requests-in-python" data-toc="enable-concurrent-requests-in-python">Enable concurrent requests in Python</h3><p id="z7crdbz_121">In <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/python25/diff27" id="z7crdbz_123" data-external="true" rel="noopener noreferrer" target="_blank">Python 2.7</a>, we introduced the ability for your application's instances to serve multiple requests concurrently in Python. Enabling this setting will decrease the number of instances needed to serve traffic for your application, but your application must be threadsafe in order for this to work correctly. Read about how to enable concurrent requests in our <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/config/appconfig#Python_app_yaml_Using_concurrent_requests" id="z7crdbz_124" data-external="true" rel="noopener noreferrer" target="_blank">Python documentation</a>. Concurrent requests are not available in the Python 2.5 runtime.</p><p id="z7crdbz_122">**Note:** All Go instances have concurrent requests enabled automatically.</p></section><section class="chapter"><h3 id="configuring-taskqueue-settings" data-toc="configuring-taskqueue-settings">Configuring TaskQueue settings</h3><p id="z7crdbz_125">The default settings for the Task Queue are tuned for performance. With these defaults, when you put several tasks into a queue simultaneously, they will likely cause new Frontend Instances to spin up. Here are some suggestions for how to tune the Task Queue to conserve Instance Hours:</p><ul class="list _bullet" id="z7crdbz_126"><li class="list__item" id="z7crdbz_127"><p id="z7crdbz_130">Set the X-AppEngine-FailFast header on tasks that are not latency sensitive. This header instructs the Scheduler to immediately fail the request if an existing instance is not available. The Task Queue will retry and back-off until an existing instance becomes available to service the request. However, it is important to note that when requests with X-AppEngine-FailFast set occupy existing instances, requests without that header set may still cause new instances to be started.</p></li><li class="list__item" id="z7crdbz_128"><p id="z7crdbz_131">Configure your Task Queue's settings(<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/queue#Queue_Definitions" id="z7crdbz_133" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/config/queue#Python_Queue_definitions" id="z7crdbz_134" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>).</p><ul class="list _bullet" id="z7crdbz_132"><li class="list__item" id="z7crdbz_135"><p id="z7crdbz_137">If you set the &quot;rate&quot; parameter to a lower value, Task Queue will execute your tasks at a slower rate.</p></li><li class="list__item" id="z7crdbz_136"><p id="z7crdbz_138">If you set the &quot;max_concurrent_requests&quot; parameter to a lower value, fewer tasks will be executed simultaneously.</p></li></ul></li><li class="list__item" id="z7crdbz_129"><p id="z7crdbz_139">Use backends(<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/backends" id="z7crdbz_140" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/backends" id="z7crdbz_141" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>) in order to completely control the number of instances used for task execution. You can use push queues with dynamic backends, or pull queues with resident backends.</p></li></ul></section><section class="chapter"><h3 id="serve-static-content-where-possible" data-toc="serve-static-content-where-possible">Serve static content where possible</h3><p id="z7crdbz_142">Static content serving (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/gettingstarted/staticfiles.html" id="z7crdbz_143" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/gettingstartedpython27/staticfiles.html" id="z7crdbz_144" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>) is handled by specialized App Engine infrastructure, which does not consume Instance Hours. If you need to set custom headers, use the Blobstore API (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/blobstore" id="z7crdbz_145" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/blobstore/" id="z7crdbz_146" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/go/blobstore/" id="z7crdbz_147" data-external="true" rel="noopener noreferrer" target="_blank">Go</a>). The actual serving of the Blob response does not consume Instance Hours.</p></section></section><section class="chapter"><h2 id="managing-application-storage" data-toc="managing-application-storage">Managing application storage</h2><p id="z7crdbz_148">App Engine calculates storage costs based on the size of entities in the datastore, the size of datastore indexes, the size of tasks in the task queue, and the amount of data stored in Blobstore. Here are some things you can do to make sure you don't store more data than necessary:</p><ul class="list _bullet" id="z7crdbz_149"><li class="list__item" id="z7crdbz_150"><p id="z7crdbz_152">Delete any entities or blobs your application no longer needs.</p></li><li class="list__item" id="z7crdbz_151"><p id="z7crdbz_153">Remove any unnecessary indexes, as discussed in the <span class="emphasis" id="z7crdbz_154">Managing Datastore Usage</span> section below, to reduce index storage costs.</p></li></ul></section><section class="chapter"><h2 id="managing-datastore-usage" data-toc="managing-datastore-usage">Managing datastore usage</h2><p id="z7crdbz_155">App Engine accounts for the number of operations performed in the Datastore. Here are a few strategies that can result in reduced Datastore resource consumption, as well as lower latency for requests to the datastore:</p><ul class="list _bullet" id="z7crdbz_156"><li class="list__item" id="z7crdbz_158"><p id="z7crdbz_168">The Cloud Platform Console dataviewer displays the number of write ops that were required to create every entity in your local datastore. You can use this information to understand the cost of writing each entity. See <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/datastore/entities.html#Understanding_Write_Costs" id="z7crdbz_169" data-external="true" rel="noopener noreferrer" target="_blank">Understanding Write Costs</a> for information on how to interpret this data.</p></li><li class="list__item" id="z7crdbz_159"><p id="z7crdbz_170">Remove any unnecessary indexes, which will reduce storage and entity write costs. Use the &quot;Get Indexes&quot; functionality (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService#getIndexes()" id="z7crdbz_171" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/datastore/functions" id="z7crdbz_172" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>) to see what indexes are defined on your application. You can see what indexes are currently serving for your application in the Cloud Platform Console <a href="https://web.archive.org/web/20160424230521/https://console.cloud.google.com/project/_/appengine/search" id="z7crdbz_173" data-external="true" rel="noopener noreferrer" target="_blank">Search page</a>.</p></li><li class="list__item" id="z7crdbz_160"><p id="z7crdbz_174">When designing your data model, you might be able to write your queries in such a way so as to avoid custom indexes altogether. Read our <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/datastore/queries" id="z7crdbz_175" data-external="true" rel="noopener noreferrer" target="_blank">Queries and Indexes</a> documentation for more information on how App Engine generates indexes.</p></li><li class="list__item" id="z7crdbz_161"><p id="z7crdbz_176">Whenever possible, replace indexed properties (which are the default) with unindexed properties (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/datastore/queries.html#Introduction_to_Indexes" id="z7crdbz_177" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/datastore/queries.html#Introduction_to_Indexes" id="z7crdbz_178" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>), which reduces the number of datastore write operations when you put an entity. Caution, if you later decide that you do need to be able to query on the unindexed property, you will need to not only modify your code to again use indexed properties, but you will have to run a <a href="https://web.archive.org/web/20160424230521/http://code.google.com/p/appengine-mapreduce/" id="z7crdbz_179" data-external="true" rel="noopener noreferrer" target="_blank">map reduce</a> over all entities to reput them.</p></li><li class="list__item" id="z7crdbz_162"><p id="z7crdbz_180">Due to the datastore query planner improvements in the App Engine 1.5.2 and 1.5.3 releases (<a href="https://web.archive.org/web/20160424230521/http://code.google.com/p/googleappengine/wiki/SdkForJavaReleaseNotes" id="z7crdbz_181" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes" id="z7crdbz_182" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>), your queries may now require fewer indexes than they did previously. While you may still choose to keep certain custom indexes for performance reasons, you may be able to delete others, reducing storage and entity write costs.</p></li><li class="list__item" id="z7crdbz_163"><p id="z7crdbz_183">Reconfigure your data model so that you can replace queries with fetch by key (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/datastore/entities.html#Saving_Getting_and_Deleting_Entities" id="z7crdbz_184" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/datastore/modelclass.html#Model_get" id="z7crdbz_185" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/go/datastore/reference.html#Get" id="z7crdbz_186" data-external="true" rel="noopener noreferrer" target="_blank">Go</a>), which is cheaper and more efficient.</p></li><li class="list__item" id="z7crdbz_164"><p id="z7crdbz_187">Use keys-only queries instead of entity queries when possible.</p></li><li class="list__item" id="z7crdbz_165"><p id="z7crdbz_188">To decrease latency, replace multiple entity <code class="code" id="z7crdbz_189">get()</code>s with a batch <code class="code" id="z7crdbz_190">get()</code>.</p></li><li class="list__item" id="z7crdbz_166"><p id="z7crdbz_191">Use datastore cursors for pagination rather than offset.</p></li><li class="list__item" id="z7crdbz_167"><p id="z7crdbz_192">Parallelize multiple datastore RPCs via the async datastore API (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/datastore/async.html" id="z7crdbz_193" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/datastore/async.html" id="z7crdbz_194" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>), or <a href="https://web.archive.org/web/20160424230521/http://golang.org/doc/effective_go.html#concurrency" id="z7crdbz_195" data-external="true" rel="noopener noreferrer" target="_blank">goroutines</a> (Go).</p></li></ul><p id="z7crdbz_157"><span class="control" id="z7crdbz_196">Note:</span> Small datastore operations include calls to allocate datastore ids or keys-only queries. See the <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/pricing#cost_resource" id="z7crdbz_197" data-external="true" rel="noopener noreferrer" target="_blank">pricing</a> page for more information on costs.</p></section><section class="chapter"><h2 id="managing-bandwidth" data-toc="managing-bandwidth">Managing bandwidth</h2><p id="z7crdbz_198">For Outgoing Bandwidth, one way to reduce usage is to, whenever possible, set the appropriate <code class="code" id="z7crdbz_200">Cache-Control</code> header on your responses and set reasonable expiration times (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/appconfig#Java_appengine_web_xml_Static_cache_expiration" id="z7crdbz_201" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/config/appconfig#Python_app_yaml_Static_file_handlers" id="z7crdbz_202" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>) for static files. Using public <code class="code" id="z7crdbz_203">Cache-Control</code> headers in this way will allow proxy servers and your clients' browser to cache responses for the designated period of time.</p><p id="z7crdbz_199">Incoming Bandwidth is more difficult to control, since that's the amount of data your users are sending to your app. However, this is a good opportunity to mention our DoS Protection Service for <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/config/dos.html" id="z7crdbz_204" data-external="true" rel="noopener noreferrer" target="_blank">Python</a> and <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/config/dos.html" id="z7crdbz_205" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>, which allows you block traffic from IPs that you consider abusive.</p></section><section class="chapter"><h2 id="managing-other-resources" data-toc="managing-other-resources">Managing other resources</h2><p id="z7crdbz_206">The last items on the report are the usages for the Email, XMPP, and Channel APIs. For these APIs, your best bet is to make sure you are using them effectively. One of the best strategies for auditing your usage of these APIs is to use Appstats (<a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/python/tools/appstats.html" id="z7crdbz_207" data-external="true" rel="noopener noreferrer" target="_blank">Python</a>, <a href="https://web.archive.org/web/20160424230521/https://cloud.google.com/appengine/docs/java/tools/appstats.html" id="z7crdbz_208" data-external="true" rel="noopener noreferrer" target="_blank">Java</a>) to make sure you're not making more calls than are necessary. Also, it's always a good idea to make sure you are checking your error rates and looking out for any invalid calls you might be making. In some cases it might be possible to catch those calls early.</p></section><div class="last-modified">10 April 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="using-custom-domains-and-ssl.html" class="navigation-links__prev">Using Custom Domains and SSL</a><a href="integrating-with-google-analytics.html" class="navigation-links__next">Integrating with Google Analytics</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>